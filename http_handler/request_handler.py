"""
This Package is responsible for all the WP-Exploiter project http requests.
The global parameters are available to modify at config.py - under the "http_data".
:global max_retries: wil hold the maximum retries in case of failre in request.
:global timeout: will hold in terms of seconds the time to wait for response for each request.
:global retries_reason: will hold the status code that will trigger another try for the request.
:global retries_break_time: the time in mil seconds to wait between retries.
:global user_agent: the user agent that will send with the request.
:requirements - python3.X, requests, urllib3, asyncio, datetime
"""
try:
    import time
    import requests
    import urllib3

    from config import http_data, logs
except Exception as e:
    if 'logs' in dir():
        logs.save_log("Import Error: {}".format(e))
    print("Import Error: {}".format(e))


_MAX_RETRIES = http_data.get('max_retries', 1)
_TIMEOUT = http_data.get('timeout', 20)  # in mil sec
_RETRIES_REASON = http_data.get('retries_reason', [])
_RETRIES_BREAK_TIME = http_data.get('retries_break_time', 1)  # in seconds
_USER_AGENT = http_data.get('user_agent', "")
_REDIRECT_STATUS = [301, 302]
_MAX_REDIRECT = 5
urllib3.disable_warnings()


class RequestHandler(object):
    """
    This is the most abstract class at the family of the http handlers - use for inhere uses only.
    Contain the most abstract method: request_content, request
    :method request_content: have default implementation
    :method request: don't have implementation and raise NotImplementError
    :method _execute: execute the request, don't have implementation and raise NotImplementError
    """
    def __init__(self):
        self._log = logs
        self._http = requests

    def request_content(
            self, url, method, params=None, timeout=_TIMEOUT, proxies=None, headers=None,
            max_retries=_MAX_RETRIES, cookies=None, redirect=True, data=None
    ):
        """
        user can invoke request with this method (and get only the request content)
        :param data: Data
        :param cookies: Cookies
        :param redirect: Allow redirection
        :param url: the URL to send the request to
        :param method: type of the request (e.g POSt, GET, etc)
        :param params: the parameters for the request (e.g parameters for post form)
        :param timeout: maximum time to wait for response
        :param proxies: witch proxies to use
        :param max_retries: maximum retries to invoke until getting response
        :param headers: the request headers
        :return: the only the request content
        :raise: an exception
        """
        if 'http' not in url:
            url = "http://{}".format(url).strip('/')
        return self.request(
            url, method, params=params, timeout=timeout, proxies=proxies, max_retries=max_retries,
            headers=headers, cookies=cookies, redirect=redirect, data=data
        )

    def _execute(self, url, method, num_of_redirects=1, params=None, timeout=_TIMEOUT,
                 proxies=None, headers=None, cookies=None, redirect=True
        ):
        """
        execute single request (can use for few retries with the request method)
        :param url: the URL to send the request to
        :param method: type of the request (e.g POSt, GET, etc)
        :param params: the parameters for the request (e.g parameters for post form)
        :param timeout: maximum time to wait for response
        :param proxies: witch proxies to use
        :param headers: the request headers
        :param num_of_redirects: the number of the redirect we passed
        :return: the full response.
        :raise: an exception
        """
        raise NotImplementedError()

    def request(
            self, url, method, params=None, timeout=_TIMEOUT, proxies=None,
            headers=None, max_retries=_MAX_RETRIES, cookies=None, redirect=True, data=None
    ):
        """
        user can invoke request with this method
        :param redirect: Allow redirection ?
        :param cookies: Cookies to send with the request
        :param url: the URL to send the request to
        :param method: type of the request (e.g POSt, GET, etc)
        :param params: the parameters for the request (e.g parameters for post form)
        :param timeout: maximum time to wait for response
        :param proxies: witch proxies to use
        :param max_retries: maximum retries to invoke until getting response
        :param headers: the request headers
        :return: the full response.
        :raise: an exception
        """
        raise NotImplementedError()

    def _check_redirect(self, response):
        """
        This function will check if redirect is necessary, the reason we maintain our redirection is to manage how
        we redirect and what we send in the new request.
        :param response: the response that got from the original request.
        :return: str with the new url
        """
        if response is None or response.status_code not in _REDIRECT_STATUS:
            return "None"
        url = response.headers.get('Location', None)
        if url is None:
            url = "None"
        return url


class HTTPHandler(RequestHandler):
    """
    This is the most simple http request class at the family of the http handlers - user for simple requests.
    Contain the most abstract method: request_content, request
    :method request_content: will inhere from the super class the default implementation and not override
    :method request: will override the and implement in the simple way with requests module.
    :method _execute:i implement in the simple way
    """
    def __init__(self):
        super().__init__()

    def _execute(
            self, url, method, num_of_redirects=1, params=None, timeout=_TIMEOUT,
            proxies=None, headers=None, cookies=None, redirect=True, data=None
        ):
        try:
            if 'http' not in url:
                url = "http://{}".format(url).strip('/')
            response = self._http.request(
                url=url, method=method, headers=headers, params=params, timeout=timeout,
                proxies=proxies, verify=False, allow_redirects=False, cookies=cookies, data=data
            )
            if redirect and num_of_redirects < _MAX_REDIRECT:
                url = self._check_redirect(response)
                if url != "None":
                    response = self._execute(
                        url=url, method=method, num_of_redirects=num_of_redirects+1, params=params, timeout=timeout,
                        proxies=proxies, headers=headers, cookies=cookies, redirect=redirect, data=data
                    )
            return response
        except requests.exceptions.RequestException as e:
            self._log.save_log(e, "Error: could not execute the request.")
            raise e

    def request(
            self, url, method, params=None, timeout=_TIMEOUT, proxies=None,
            headers=None, max_retries=_MAX_RETRIES, cookies=None, redirect=True, data=None
    ):
        # try fist time with the user original request (http or https) & second time the opposite.
        try:
            if headers is None:
                headers = dict()
            if headers.get('User-Agent', None) is None:
                headers['User-Agent'] = _USER_AGENT
            for i in range(0, max_retries+1):  # + 1 is for the first try
                response = self._execute(
                    url=url, method=method, params=params, timeout=_TIMEOUT, proxies=proxies, headers=headers,
                    cookies=cookies, redirect=True, data=data
                )
                if i < max_retries and (response is None or response.status_code in _RETRIES_REASON):
                    time.sleep(_RETRIES_BREAK_TIME)  # try again if failed after X seconds.
                else:
                    return response
        except Exception as e:
            self._log.save_log(e, "Error: could not handle the request.")
            raise e  # throw the exception for the user to choose how to handle it.
        return None  # requests is failed, return None


class HTTPWithSession(HTTPHandler):
    """
    This is the class that inhere from HTTPHandler and adapt the request to save Session state.
    Contain the most abstract method: request_content, request
    :method request_content: will inhere from the super class the default implementation and not override.
    :method request: will inhere from the super class the default implementation and not override.
    :method _execute: will inhere from the super class the default implementation and not override.
    :method clean_session: unique for this class
    """
    def __init__(self):
        super().__init__()
        self._http = requests.Session()

    def clean_session(self):
        """
        This method will clean the session, and create new one.
        :return: None
        :raises: requests.Session() Exceptions.
        """
        self._http.close()
        self._http = requests.Session()