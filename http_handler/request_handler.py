try:
    import time
    import requests
    import urllib3

    from wordpress import WPLogs
    from config import http_data
except ImportError as e:
    print("Import Error: ", e)
    exit(-1)

_MAX_RETRIES = http_data.get('max_retries', 1)
_TIMEOUT = http_data.get('timeout', 20)  # in mil sec
_RETRIES_REASON = http_data.get('retries_reason', [])
_RETRIES_BREAK_TIME = http_data.get('retries_break_time', 1)  # in seconds
_USER_AGENT = http_data.get('user_agent', "")

urllib3.disable_warnings()


class RequestHandler(object):

    def __init__(self):
        self._log = WPLogs()

    def request_content(self, url, method, params=None, timeout=_TIMEOUT, proxies=None, headers=None,
                        max_retries=_MAX_RETRIES):
        """
        user can invoke request with this method (and get only the request content)
        :param url: the URL to send the request to
        :param method: type of the request (e.g POSt, GET, etc)
        :param params: the parameters for the request (e.g parameters for post form)
        :param timeout: maximum time to wait for response
        :param proxies: witch proxies to use
        :param max_retries: maximum retries to invoke until getting response
        :param headers: the request headers
        :return: the only the request content
        :raise: un exception
        """
        return self.request(url, method, params=params, timeout=timeout, proxies=proxies, max_retries=max_retries,
                            headers=headers)

    def _execute(self, url, method, params=None, timeout=_TIMEOUT, proxies=None, headers=None):
        """
        execute single request (can use for few retries with the request method)
        :param url: the URL to send the request to
        :param method: type of the request (e.g POSt, GET, etc)
        :param params: the parameters for the request (e.g parameters for post form)
        :param timeout: maximum time to wait for response
        :param proxies: witch proxies to use
        :param headers: the request headers
        :return: the full response.
        :raise: un exception
        """
        raise NotImplementedError()

    def request(self, url, method, params=None, timeout=_TIMEOUT, proxies=None, headers=None, max_retries=_MAX_RETRIES):
        """
        user can invoke request with this method
        :param url: the URL to send the request to
        :param method: type of the request (e.g POSt, GET, etc)
        :param params: the parameters for the request (e.g parameters for post form)
        :param timeout: maximum time to wait for response
        :param proxies: witch proxies to use
        :param max_retries: maximum retries to invoke until getting response
        :param headers: the request headers
        :return: the full response.
        :raise: un exception
        """
        raise NotImplementedError()


class HTTPHandler(RequestHandler):

    def __init__(self):
        super().__init__()

    def _execute(self, url, method, params=None, timeout=_TIMEOUT, proxies=None, headers=None):
        try:
            response = requests.request(url=url, method=method, headers=headers, params=params, timeout=timeout, proxies=proxies, verify=False)
            return response
        except Exception as e:
            self._log.save_log(e, "Error: could not execute the request.")
            raise e

    def request(self, url, method, params=None, timeout=_TIMEOUT, proxies=None, headers=None, max_retries=_MAX_RETRIES):
        # try fist time with the user original request (http or https) & second time the opposite.
        try:
            if headers is None:
                headers = dict()
            if headers.get('User-Agent', None) is None:
                headers['User-Agent'] = _USER_AGENT
            for i in range(0, max_retries+1):  # + 1 is for the first try
                response = self._execute(url=url, method=method, params=params, timeout=_TIMEOUT, proxies=proxies, headers=headers)
                if i < max_retries and (response is None or response.status_code in _RETRIES_REASON):
                    time.sleep(_RETRIES_BREAK_TIME)  # try again if failed after X seconds.
                else:
                    return response
        except Exception as e:
            self._log.save_log(e, "Error: could not handle the request.")
            raise e  # throw the exception for the user to choose how to handle it.

        return None  # requests is failed, return None


class HTTPWithSession(HTTPHandler):

    def __init__(self):
        super().__init__()
        self._session = requests.Session()

    def _execute(self, url, method, params=None, timeout=_TIMEOUT, proxies=None, headers=None):
        # this methode will be save the session state for the request
        # if you want to invoke new request with new session you shuold clean the session first.
        try:
            response = self._session.request(method=method, url=url,data=params,headers=headers,timeout=timeout, proxies=proxies, verify=False)
            return response
        except Exception as e:
            self._log.save_log(e, "Error: could not execute the request.")
            raise e

    def clean_session(self):
        self._session.close()
        self._session = requests.Session()







