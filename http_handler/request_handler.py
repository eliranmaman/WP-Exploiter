"""
This Package is responsible for all the WP-Exploiter project http requests.
The global parameters are available to modify at config.py - under the "http_data".
:global max_retries: wil hold the maximum retries in case of failre in request.
:global timeout: will hold in terms of seconds the time to wait for response for each request.
:global retries_reason: will hold the status code that will trigger another try for the request.
:global retries_break_time: the time in mil seconds to wait between retries.
:global user_agent: the user agent that will send with the request.
:requirements - python3.X, requests, urllib3, asyncio, datetime
"""
try:
    import time
    import requests
    import urllib3

    from config import http_data, logs
except Exception as e:
    if 'logs' in dir():
        logs.save_log("Import Error: {}".format(e))
    print("Import Error: {}".format(e))


_MAX_RETRIES = http_data.get('max_retries', 1)
_TIMEOUT = http_data.get('timeout', 20)  # in mil sec
_RETRIES_REASON = http_data.get('retries_reason', [])
_RETRIES_BREAK_TIME = http_data.get('retries_break_time', 1)  # in seconds
_USER_AGENT = http_data.get('user_agent', "")
urllib3.disable_warnings()


class RequestHandler(object):
    """
    This is the most abstract class at the family of the http handlers - use for inhere uses only.
    Contain the most abstract method: request_content, request
    :method request_content: have default implementation
    :method request: don't have implementation and raise NotImplementError
    :method _execute: execute the request, don't have implementation and raise NotImplementError
    """
    def __init__(self):
        self._log = logs

    def request_content(self, url, method, params=None, timeout=_TIMEOUT, proxies=None, headers=None,
                        max_retries=_MAX_RETRIES):
        """
        user can invoke request with this method (and get only the request content)
        :param url: the URL to send the request to
        :param method: type of the request (e.g POSt, GET, etc)
        :param params: the parameters for the request (e.g parameters for post form)
        :param timeout: maximum time to wait for response
        :param proxies: witch proxies to use
        :param max_retries: maximum retries to invoke until getting response
        :param headers: the request headers
        :return: the only the request content
        :raise: an exception
        """
        if 'http' not in url:
            url = "http://{}".format(url).strip('/')
        return self.request(url, method, params=params, timeout=timeout, proxies=proxies, max_retries=max_retries,
                            headers=headers)

    def _execute(self, url, method, params=None, timeout=_TIMEOUT, proxies=None, headers=None):
        """
        execute single request (can use for few retries with the request method)
        :param url: the URL to send the request to
        :param method: type of the request (e.g POSt, GET, etc)
        :param params: the parameters for the request (e.g parameters for post form)
        :param timeout: maximum time to wait for response
        :param proxies: witch proxies to use
        :param headers: the request headers
        :return: the full response.
        :raise: an exception
        """
        raise NotImplementedError()

    def request(self, url, method, params=None, timeout=_TIMEOUT, proxies=None, headers=None, max_retries=_MAX_RETRIES):
        """
        user can invoke request with this method
        :param url: the URL to send the request to
        :param method: type of the request (e.g POSt, GET, etc)
        :param params: the parameters for the request (e.g parameters for post form)
        :param timeout: maximum time to wait for response
        :param proxies: witch proxies to use
        :param max_retries: maximum retries to invoke until getting response
        :param headers: the request headers
        :return: the full response.
        :raise: an exception
        """
        raise NotImplementedError()


class HTTPHandler(RequestHandler):
    """
    This is the most simple http request class at the family of the http handlers - user for simple requests.
    Contain the most abstract method: request_content, request
    :method request_content: will inhere from the super class the default implementation and not override
    :method request: will override the and implement in the simple way with requests module.
    :method _execute:i implement in the simple way
    """
    def __init__(self):
        super().__init__()

    def _execute(self, url, method, params=None, timeout=_TIMEOUT, proxies=None, headers=None):
        try:
            if 'http' not in url:
                url = "http://{}".format(url).strip('/')
            response = requests.request(url=url, method=method, headers=headers, params=params, timeout=timeout, proxies=proxies, verify=False)
            return response
        except requests.exceptions.RequestException as e:
            self._log.save_log(e, "Error: could not execute the request.")
            raise e

    def request(self, url, method, params=None, timeout=_TIMEOUT, proxies=None, headers=None, max_retries=_MAX_RETRIES):
        # try fist time with the user original request (http or https) & second time the opposite.
        try:
            if headers is None:
                headers = dict()
            if headers.get('User-Agent', None) is None:
                headers['User-Agent'] = _USER_AGENT
            for i in range(0, max_retries+1):  # + 1 is for the first try
                response = self._execute(
                    url=url, method=method, params=params, timeout=_TIMEOUT, proxies=proxies, headers=headers
                )
                if i < max_retries and (response is None or response.status_code in _RETRIES_REASON):
                    time.sleep(_RETRIES_BREAK_TIME)  # try again if failed after X seconds.
                else:
                    return response
        except Exception as e:
            self._log.save_log(e, "Error: could not handle the request.")
            raise e  # throw the exception for the user to choose how to handle it.
        return None  # requests is failed, return None


class HTTPWithSession(HTTPHandler):
    """
    This is the class that inhere from HTTPHandler and adapt the request to save Session state.
    Contain the most abstract method: request_content, request
    :method request_content: will inhere from the super class the default implementation and not override.
    :method request: will inhere from the super class the default implementation and not override.
    :method _execute: will override the implementation to use session.
    :method clean_session: unique for this class
    """
    def __init__(self):
        super().__init__()
        self._session = requests.Session()

    def _execute(self, url, method, params=None, timeout=_TIMEOUT, proxies=None, headers=None):
        """
        This method will be save the session state for the request
        If you want to invoke new request with new session you should clean the session first.
        """
        try:
            if 'http' not in url:
                url = "http://{}".format(url).strip('/')
            response = self._session.request(
                method=method, url=url, data=params, headers=headers, timeout=timeout, proxies=proxies, verify=False
            )
            return response
        except requests.exceptions.RequestException as e:
            self._log.save_log(e, "Error: could not execute the request.")
            raise e

    def clean_session(self):
        """
        This method will clean the session, and create new one.
        :return: None
        :raises: requests.Session() Exceptions.
        """
        self._session.close()
        self._session = requests.Session()