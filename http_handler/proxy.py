from itertools import cycle


class Proxy:

    def __init__(self, proxies=None):
        """
        This class will handle all the proxies we want to maintain
            :param address_pool: pool of addresses
            :param addresses_cycle: addresses cycle - which with we can randomly pick one
            :param proxies:
        """
        self._address_pool = set() if proxies is None else set(proxies)
        self._address_pool_cycle = cycle(self._address_pool)

    def add_proxy(self, url, port):
        """
        this method adds new address to the addresses' set
        :param url: string of the url or ip
        :param port: string of the desired port
        """
        address = "{}:{}".format(url, port)
        self._address_pool.add(address)
        self._address_pool_cycle = cycle(self._address_pool)  # updating the cycle

    def remove_proxy(self, url, port):
        """
        this method removes a specific address from the pool
        :param url: string of the url or ip
        :param port: string of the desired port
        """
        address = "{}:{}".format(url, port)
        self._address_pool.remove(address)
        self._address_pool_cycle = cycle(self._address_pool)  # updating the cycle

    def get_proxy(self):
        """
        this method converts random address from the pool to proxy
        :return: random proxy
        :rtype: dict
        """
        address = next(self._address_pool_cycle)  # pick random address
        proxy = {"http": address, "https": address}
        return proxy

    def get_all_proxies(self):
        """
        this method converts all the addresses in the pool to proxies (http & https)
        :return: all the addresses as proxies after conversion
        :rtype: array of dicts (json)
        """
        proxies = []
        for addr in self._address_pool:
            proxy = {"http": addr, "https": addr}
            proxies.append(proxy)
        return proxies
