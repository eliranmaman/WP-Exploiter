#!/usr/bin/python3

"""
log-tool is a blade ranger utility used to manipulate logs recorded by core_autonomy runs.
Usually the logs are kept in dump extension files under the /br NFS, i.e.:

 /br/logs/larry/robot-larry-20200825_113405+0300_robot-upload/20200825_113241.dump

log-tool can give a shell directly or upload to the database, which is done via inotify.
"""

from pdb import set_trace as b
import sys
from collections import defaultdict
import os
from os.path import basename, dirname, split
from os import environ, path

from pickle import loads, dumps, HIGHEST_PROTOCOL
from datetime import datetime
import re
from time import time
from subprocess import check_output
from struct import pack, unpack
from functools import wraps
from contextlib import ExitStack
from enum import Enum
from numpy import sign
from pathlib import Path

from psycopg2 import Binary
from psycopg2.extensions import register_adapter, QuotedString
from sqlalchemy.exc import ProgrammingError
import pytz
import sqlalchemy
import click
import pandas as pd

DEFAULT_TIMEZONE = 'Israel'
DEFAULT_FILES_GLOB_LIST = ["cleaning_algorithm-*.log", "*.dump"]


def assert_limit(limit):
    def wrapit(f):
        @wraps(f)
        def wrapper(*args, **kw):
            ret = f(*args, **kw)
            assert len(ret) <= limit
            return ret

        return wrapper

    return wrapit


# Postgresql has a limit of 63 chars per identifier
assert_valid_table_name = assert_limit(63)


def sanitize_postgresql_table_name(name):
    tt = ''.join(chr(i) if chr(i) not in '/-.;[](){}' else '_' for i in range(256))
    return str(name.lower()).translate(tt)


@assert_valid_table_name
def key_to_table_name(k):
    if k[0] == '/':
        k = k[1:]
    ret = sanitize_postgresql_table_name('fk_{}'.format(str(k)))
    return ret


@assert_valid_table_name
def type_to_table_name(type_):
    return sanitize_postgresql_table_name('ft_{}'.format(str(type_)))



@click.group()
def cli():
    pass


@click.command()
@click.option('--filename', default='/dev/stdin', help='file to dump, defaults to stdin')
def dump(filename):
    print("h")


@click.command()
@click.option('--fullpath', default='/dev/stdin', help='file to dump, defaults to stdin')
@click.option('--limit', default=None, type=int, help='limit to first N messages')
@click.option('--output', default='csv', type=click.Choice(['csv', 'excel', 'hdf', 'db']),
              help='output format')
@click.option('--output-filename', default='/dev/stdout')
@click.option('--verbose', is_flag=True, help='show more information', default=False)
@click.option('--debug', is_flag=True, help='do not capture exceptions for easier debugging', default=False)
@click.option('--remove-existing', is_flag=True, default=False, help='DANGEROUS removes existing run if found')
def to(fullpath, limit, output, output_filename, verbose, debug, remove_existing):
    path_object = Path(fullpath)  # this is the path object (to gain more information about the path)
    if not path_object.exists():
        print("path is not exist.")
        return



@click.command()
@click.option('--filename', required=True, help='filename to interactively look at')
@click.option('--limit', default=None, type=int, help='limit to first N messages')
@click.option('--timezone', help='timezone for timestamps when going to db', default=DEFAULT_TIMEZONE)
def shell(filename, limit, timezone):
    pass

@click.command()
@click.option('--filename', default='/dev/stdin')
@click.option('--timezone', help='timezone for timestamps when going to db', default=DEFAULT_TIMEZONE)
def summary(filename, timezone):
    pass

def take_first(filename, limit):
    ret = []
    with open(filename, 'rb') as fd:
        for i in range(limit):
            s = unpack('<H', fd.read(2))[0]
            ret.append((s, loads(fd.read(s))))
    return ret


@click.command()
@click.option('--url', help='Full url you wigh to scan, for example: https://example.com')
@click.option('--output', default='/dev/stdout')
@click.option('--limit', help='number of messages to trim to', default=1000)
def detect(filename, output, limit):
    first = take_first(filename=filename, limit=limit)
    with open(output, 'wb+') as fd:
        for _s, x in first:
            pickled = dumps(x, HIGHEST_PROTOCOL)
            fd.write(pack('<H', len(pickled)))
            fd.write(pickled)


cli.add_command(trim)
cli.add_command(dump)
cli.add_command(to)
cli.add_command(shell)
cli.add_command(summary)


def main():
    cli()


if __name__ == '__main__':
    main()