"""
This Package is responsible to detect WordPress websites, In the wild.
The global parameters are available to modify in config.py - under the "detector_data".
:global admin_path: the admin panel path.
:global login_path: the login page of the web.
:global feed_path: the path for the feed xml.
:global upgrade_path: the path for the upgrade page of WordPress.
:global timeout: maximum time to wait for response (http requests).
:global css_path: the path to the css folder of the website.
:global detect_th: the threshold number(low number = high sensitivity).
:requirements - python3.X, ElementTree, urllib.parse, requests, urllib3, asyncio, datetime.
"""
try:
    import enum
    import re
    import xml.etree.ElementTree as ET
    from urllib.parse import parse_qs, urlparse

    from http_handler import HTTPHandler
    from config import detector_data, logs
except Exception as e:
    if 'logs' in dir():
        logs.save_log("Import Error: {}".format(e))
    print("Import Error: ", e)


def check_legitimate_ver(version):
    """
    This function check if the version is legitimate, only digits and dot.
    :param version:  str
    :return: boolean
    """
    return re.match("^[0-9.]+$", version)


_ADMIN_PATH = detector_data.get('admin_path', "/wp-admin")
_LOGIN_PATH = detector_data.get('login_path', "wp-login.php")
_FEED_PATH = detector_data.get('feed_path', "/feed")
_UPGRADE_PATH = detector_data.get('upgrade_path', "{}/upgrade.php".format(_ADMIN_PATH))
_TIMEOUT = detector_data.get('timeout', 5)  # in sec.
_CSS_PATH = detector_data.get('css_path', [])


class WPDetector(object):
    """
    This class is an implementation for Detector module, will detect if the site is WordPress or not.
    The class don't have the capability to bypass FireWalls.
    :method get_version: return the WordPress version (if detected) of the given url.
    :method detect: if the given url are operating byt WordPress system or not.
    """
    def __init__(self, domain, proxies=None, timeout=_TIMEOUT):
        """
        :param domain: the url site we want to detect.
        :param proxies: proxies (recommended to increase privacy) to use.
        :param timeout: the time to wait for response (http request)
        """
        self._http_handler = HTTPHandler()
        self._proxies = proxies
        self._words_values = {"/wp-content/": 0.8, '<meta name="generator" content="WordPress': 0.8,
                              "/wordpress/": 0.8, "WordPress": 0.2, "wp-emoji-release.min.js": 0.8}
        self._files_needles = {"license.txt": "WordPress - Web publishing software",
                               "readme.html": "Semantic Personal Publishing Platform"}
        self._web_data = dict()
        self._url = "{}".format(domain).strip('/')
        self._is_wp = False
        self._timeout = timeout
        self._logs = logs

    def __check_admin_panel(self, url):
        """
        This is private method using to detect with the panel admin
        :param url: url to detect
        :return: 1 in case of detection and 0 in case of unknown.
        """
        response = self.__get_page_data(url)
        if response is not None and _LOGIN_PATH in str(response.url):
            return True
        return False  # not WordPress site

    def __check_words(self, url):
        """
        This is private method using to check specific words are related to
        WordPress sites in the given url GET response.
        :param url: the url to check
        :return: Float (using for the thrash hold detection)
        """
        probability = 0
        response = self.__get_page_data(url)
        if response is None:
            return 0.0
        content = str(response.content)
        if content is not None:
            for word, value in self._words_values.items():
                if word in content:
                    probability += value
            return probability
        return 0.0

    def __check_files(self, url):
        """
        This is private method using to check specific files are related to
        WordPress sites in the given url.
        :param url: the url to check
        :return: Float (using for the thrash hold detection)
        """
        counter = 0
        for file, needle in self._files_needles.items():
            assembled_url = "{}/{}".format(url, file)
            response = self.__get_page_data(assembled_url)
            if response is None:
                return 0.0
            content = str(response.content)
            if needle in content:
                counter += 1
        return counter/len(self._files_needles.keys())

    def get_version(self, url=None, timeout=_TIMEOUT):
        """
        This method will return the url WordPress version (if possible)
        :param url: the url to check
        :param timeout: maximum time to wait for response (http requests)
        :return: str
        """
        try:
            if url is None:
                url = self._url
            self._timeout = timeout
            url = "{}".format(url).strip('/')
            version = "Unknown"
            try:
                version = self.__find_version_in_source(url)
            except Exception as e:
                self._logs.save_log(e, "Error: __find_version_in_source function invoke from get_version is failed.")
            if version != "Unknown" and check_legitimate_ver(version):
                return version
            # try the 2nd method to detect the version
            try:
                target_url = "{}{}".format(url, _FEED_PATH)
                version = self.__find_version_in_feed(target_url)
            except Exception as e:
                self._logs.save_log(e, "Error: __find_version_in_feed function invoke from get_version is failed.")
            if version != "Unknown" and check_legitimate_ver(version):
                return version
            # try the 3rd method to detect the version
            try:
                target_url = "{}{}".format(url, _UPGRADE_PATH)
                version = self.__find_version_in_source(target_url)
            except Exception as e:
                self._logs.save_log(e, "Error: __find_version_in_source(_UPGRADE_PATH)"
                                       " function invoke from get_version is failed.")
            if not check_legitimate_ver(version):
                version = "Unknown"
            return version
        except Exception as e:
            print("Something goes wrong, please check the logs file.", e)
            self._logs.save_log(e)
            return "Unknown"

    def __find_version_in_feed(self, url):
        """
        This is private method using to check the version in the feed
        web site     in the given url.
        :param url: the url to check
        :return: str
        """
        response = self.__get_page_data(url)  # get page data from cache (or invoke new request)
        if response is None:
            return "Unknown"
        if 'xml' not in response.headers.get('Content-Type', ""):
            return "Unknown"
        response = response.content
        if response is None:
            return "Unknown"
        page = ET.fromstring(response)  # page => to xml
        ver_url = page.find('rss')
        if ver_url is None:
            return "Unknown"
        ver_url = ver_url.find('channel')
        if ver_url is None:
            return "Unknown"
        ver_url = ver_url.find('generator')
        if ver_url is None:
            return "Unknown"
        ver_url = urlparse(ver_url)  # extract the v parameter
        version = parse_qs(ver_url.query)['v'][0]
        return version

    def __find_version_in_source(self, url):
        """
        This is private method using to check the version in the html source
        file of the given url.
        :param url: the url to check
        :return: str
        """
        version = "Unknown"
        response = self.__get_page_data(url)
        if response is None:
            return "Unknown"
        data = str(response.content)
        for css_item in _CSS_PATH:  # foreach item in the _CSS_PATH do
            if css_item not in data:
                continue
            version = data.partition(css_item)[2].partition("\"")[0]
            if len(version) > 10:  # if the len is bigger then 10 its need another parse
                version = version.split("\\")[0].split("\'")[0]
            if not re.match("^[0-9.]+$", version):  # check if the string contain only digits and .
                version = "Unknown"  # no version found.
        return version

    def __check_if_wp(self, url):
        """
        This is private method using to check if the site is WordPress by
        using few other methods.
        :param url: the url to check
        :return: str
        """
        words_prob = self.__check_words(url)
        files_prob = self.__check_files(url)
        return (words_prob+files_prob)/2

    def detect(self, url=None, sensitivity=0.6, timeout=_TIMEOUT):
        """
        This method will detect if a given url is a WordPress site or not (if possible).
        :param url: the url to check
        :param sensitivity: the threshold sensitivity (double from 0.6 to 1 - high value is none sensitive at all)
        :param timeout: maximum time to wait for response (http requests)
        :return: True or False
        """
        try:
            print("Start checking ...")
            if url is None:
                url = self._url
            url = "{}".format(url).strip('/')
            self._timeout = timeout
            try:
                print("Check if WP admin panel is exist")
                if self.__check_admin_panel("{}{}".format(url, _ADMIN_PATH)):  # if found WP admin panel => is WP!
                    print("\tThis is a WP site.")
                    return True
                print("\tno standard WP admin panel.")
            except Exception as e:
                print("\tNo conclusion")
                self._logs.save_log(e, "Error: detect =>  __check_admin_panel invoke failed for: {}".format(url))
            try:
                print("Check few others arguments (e.g: common css files, etc.)")
                prob = self.__check_if_wp(url)
                if prob is None:
                    print("\tThis is not WP site.")
                    return False
            except Exception as e:
                print("\tNo conclusion")
                self._logs.save_log(e, "Error: could not load page")
                return False
            if prob >= sensitivity:
                print("\tThis is a WP site.")
                return True
            else:
                print("\tThis is not a WP site.")
                return False
        except Exception as e:
            print("Something goes wrong, please check the logs file.", e)
            self._logs.save_log(e)
            return False

    def __get_page_data(self, url):
        """
        This is a private method using to get a url from previous requests.
        Helping to avoid several request for the same page, this method are operated as a cache management.
        If the request if available return the previous request, otherwise generate new request and
        store the data for future using.
        :param url: the requested page
        :return: response
        """
        response = self._web_data.get(url, None)
        if response is None:
            response = self._http_handler.request(url=url, method="GET", timeout=self._timeout, proxies=self._proxies)
            self._web_data[url] = response
        return response

