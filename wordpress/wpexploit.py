# Nethanel Gelernter (c)
from abc import ABC
from wordpress.wplogs import WPLogs
from http_handler.request_handler import HTTPWithSession
class WPExploit(object):

    def __init__(self, domain, additional_data=None, proxies=None):
        self._url = str(domain)
        self._additional_data = additional_data
        self._proxies = proxies
        self._logs = WPLogs()
        self._references = list()
        '''
        Keep state of data that is collected and tries that were performed for efficieny
        :param domain:
        :param additional_data: data that might be useful for performing the bruteforce (e.g., login page URL)
        :param proxies: working via HTTP proxies
        '''

    def plugin_name(self):
        '''

        :return: the vulnerable plugin's name
        '''

    def vulnerable_versions(self):
        '''

        :return: string the describes the ranges of vulnerable methods
        '''
        raise NotImplementedError()

    def is_vulnerable_version(self, version_str):
        '''

        :param version_str: X.Y.Z....
        :return: Whether the version is vulnerable or not
        '''
        raise NotImplementedError()

    def get_references(self):
        '''

        :return: list of URLs for data about the exploit & vulnerability (where did you find the data?)
        '''
        return self._references

    def is_vulnerable(self, data=None, proxies=None):
        '''
        Test whether vulnerable or not. If many requests or suspicious requests might be sent, consider adding
        aggresive parameter
        :param data: dictionary with data that can be used for the method
        :param proxies: working via HTTP proxies. If None, the constructor's proxies are used (if any)
        :return: Boolean - whether domain is vulnerable or not
        '''
        raise NotImplementedError()

    def exploit(self, data=None, proxies=None):
        '''
        If possible to exploit (E.g., in server-side vulns) - exploit
        In client-side, return the exploit code to use
        :param data: dictionary with data that can be used for the method
        :param proxies: working via HTTP proxies. If None, the constructor's proxies are used (if any)
        :return: Boolean - success or not
        '''
        raise NotImplementedError()

    def _save_log(self, e, msg=None, print_error=False):
        if print_error is True:
            print(msg)
        self._logs.save_log(e)
        if msg is not None:
            self._save_log(msg)

    # Feel free to add public method that you consider to be relevant for the users
    # user _ and __ for private and protected methods that should not be used outside the class


class WPPluginExploiter(WPExploit):

    def __init__(self, domain):
        super().__init__(domain)
        self._plugin_name = None
        self._plugin_version_start = "Unknown"  # override with the start vulnerable versions
        self._plugin_version_end = "Unknown"  # override with the end vulnerable versions
        self._plugin_version_start_op = " <= "
        self._plugin_version_end_op = " <= "
        self._http = HTTPWithSession()

    def vulnerable_versions(self):
        try:
            if self._plugin_version_start is "Unknown": return "Unknown"
            elif self._plugin_version_end is "Unknown": return "Unknown"
            version = str(self._plugin_version_start)+str(self._plugin_version_start_op)
            version += "Plugin Version"
            version += str(self._plugin_version_end_op)+str(self._plugin_version_end)
            return version
        except Exception as e:
            self._save_log(e, "Error: vulnerable_versions function has crashed, please try again later.")
            return None

    def is_vulnerable_version(self, version_str):
        try:
            start_version = str(self._plugin_version_start).replace(".", "").replace(" ", "")
            end_version = str(self._plugin_version_end).replace(".", "").replace(" ", "")
            test_version = str(version_str).replace(".", "").replace(" ", "")
            max_digits = len(start_version)
            if len(end_version) > max_digits:
                max_digits = len(end_version)
            if len(test_version) > max_digits:
                max_digits = len(test_version)
            start_version = self._build_version(start_version, max_digits)
            end_version = self._build_version(end_version, max_digits)
            test_version = self._build_version(test_version, max_digits)
            if self._plugin_version_start_op is " < " and self._plugin_version_end_op is " < ":
                return start_version < test_version < end_version
            elif self._plugin_version_start_op is " <= " and self._plugin_version_start_op is " < ":
                return  start_version <= test_version < end_version
            elif self._plugin_version_start_op is " < " and self._plugin_version_end_op is " <= ":
                return start_version < test_version <= end_version
            return start_version <= test_version <= end_version
        except Exception as e:
            print("Error: could not parse version.")
            print(e)
            return None

    def is_vulnerable(self, data=None, proxies=None):
        readme = False
        try:
            readme = self._readme_file(proxies)
        except Exception as e:
            self._save_log(e, "Error: find version of plugin with readme file failed.", False)
        return readme

    def _readme_file(self, proxies=None):
        raise NotImplementedError()

    def exploit(self, data=None, proxies=None):
        raise NotImplementedError()

    def _build_version(self, version, num_of_digits):
        version = str(version)
        version += ("0"*(num_of_digits-len(version)))
        try:
            version = int(version)
            return version
        except Exception as e:
            self._save_log(e, "Error: while parsing version number: "+str(version), True)
            raise e


class WPDatabaseReset(WPPluginExploiter):

    _USERNAME = "elroattacker"
    _PASS = "123456"
    _EMAIL = "elro@elro.eliranm.co"
    _EMAIL_SERVER = "elro.eliranm.co"
    _EMAIL_PASS = "elroWordpress"

    def __init__(self, domain):
        super().__init__(domain)
        self._plugin_version_start = 0
        self._plugin_version_end = "3.15"
        self._plugin_version_start_op = " <= "
        self._plugin_version_end_op = " < "
        self._references = ['https://www.wordfence.com/blog/2020/01/easily-exploitable-vulnerabilities-patched-in-wp-database-reset-plugin',
                            'https://blog.qualys.com/webappsec/2020/01/24/wordpress-database-reset-plugin-vulnerability-cve-2020-7047-cve-2020-7048',
                            'https://wpvulndb.com/vulnerabilities/10027']

    def _readme_file(self, proxies=None):
        url = self._url+"/wp-content/plugins/wordpress-database-reset/readme.txt"
        response = self._http.request(url=url, method="GET", proxies=proxies)
        if response is None:
            return False
        if "Stable tag:" not in response.text:
            return False
        version = response.text.split("Stable tag:")[1].split("\n")[0]  # get the version of the plugin
        return self.is_vulnerable_version(version)

    def exploit(self, data=None, proxies=None):
        """
        :param data: dictionary with data username & password for login, if dictionary is None,
                     the exploit will try to register.
                     admin_login_page: will hold the admin_login_page url
                     cannot send only the username & password => must send all the parameters or none!
        """
        possible = self.is_vulnerable()
        if possible is False:
            return None
        if data is None:
            possible = self.__register(proxies=proxies, data=data)
            data = {"username": self._USERNAME, "password": self._PASS,
                    "admin_login_page": self._url+"/wp-login.php",
                    "register_page": self._url+"/wp-login.php?action=register" }
        data['mail_server'] = self._EMAIL_SERVER
        data['mail_user'] = self._EMAIL
        data['mail_pass'] = self._EMAIL_PASS
        if possible is False:
            return None
        pass #  stop here

    def __register(self,data, proxies=None):
        pass

    def __validate_register(self, data, proxies=None):




        return True

