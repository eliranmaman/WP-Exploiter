# Nethanel Gelernter (c)
from abc import ABC
from wordpress.wplogs import WPLogs
from http_handler.request_handler import HTTPWithSession
class WPExploit(object):

    def __init__(self, domain, additional_data=None, proxies=None):
        self._url = str(domain)
        self._additional_data = additional_data
        self._proxies = proxies
        self._logs = WPLogs()
        self._references = list()
        '''
        Keep state of data that is collected and tries that were performed for efficieny
        :param domain:
        :param additional_data: data that might be useful for performing the bruteforce (e.g., login page URL)
        :param proxies: working via HTTP proxies
        '''

    def plugin_name(self):
        '''

        :return: the vulnerable plugin's name
        '''

    def vulnerable_versions(self):
        '''

        :return: string the describes the ranges of vulnerable methods
        '''
        raise NotImplementedError()

    def is_vulnerable_version(self, version_str):
        '''

        :param version_str: X.Y.Z....
        :return: Whether the version is vulnerable or not
        '''
        raise NotImplementedError()

    def get_references(self):
        '''

        :return: list of URLs for data about the exploit & vulnerability (where did you find the data?)
        '''
        return self._references

    def is_vulnerable(self, data=None, proxies=None):
        '''
        Test whether vulnerable or not. If many requests or suspicious requests might be sent, consider adding
        aggresive parameter
        :param data: dictionary with data that can be used for the method
        :param proxies: working via HTTP proxies. If None, the constructor's proxies are used (if any)
        :return: Boolean - whether domain is vulnerable or not
        '''
        raise NotImplementedError()

    def exploit(self, data=None, proxies=None):
        '''
        If possible to exploit (E.g., in server-side vulns) - exploit
        In client-side, return the exploit code to use
        :param data: dictionary with data that can be used for the method
        :param proxies: working via HTTP proxies. If None, the constructor's proxies are used (if any)
        :return: Boolean - success or not
        '''
        raise NotImplementedError()

    def _save_log(self, e, msg=None, print_error=False):
        if print_error is True:
            print(msg)
        self._logs.save_log(e)
        if msg is not None:
            self._save_log(msg)

    def _build_version(self, version):
        raise NotImplementedError()

    # Feel free to add public method that you consider to be relevant for the users
    # user _ and __ for private and protected methods that should not be used outside the class


class WPPluginExploiter(WPExploit):

    def __init__(self, domain):
        super().__init__(domain)
        self._plugin_name = None
        self._plugin_version_start = "Unknown"  # override with the start vulnerable versions
        self._plugin_version_end = "Unknown"  # override with the end vulnerable versions
        self._plugin_version_start_op = " <= "
        self._plugin_version_end_op = " <= "
        self._http = HTTPWithSession()

    def vulnerable_versions(self):
        try:
            if self._plugin_version_start is "Unknown": return "Unknown"
            elif self._plugin_version_end is "Unknown": return "Unknown"
            version = str(self._plugin_version_start)+str(self._plugin_version_start_op)
            version += "Plugin Version"
            version += str(self._plugin_version_end_op)+str(self._plugin_version_end)
            return version
        except Exception as e:
            self._save_log(e, "Error: vulnerable_versions function has crashed, please try again later.")
            return "Unknown"

    def is_vulnerable_version(self, version_str):
        try:
            start_version = self._build_version(self._plugin_version_start)
            end_version = self._build_version(self._plugin_version_end)
            test_version = self._build_version(str(version_str))
            if self._plugin_version_start_op is " < " and self._plugin_version_end_op is " < ":
                return start_version < test_version < end_version
            elif self._plugin_version_start_op is " <= " and self._plugin_version_start_op is " < ":
                return  start_version <= test_version < end_version
            elif self._plugin_version_start_op is " < " and self._plugin_version_end_op is " <= ":
                return start_version < test_version <= end_version
            return start_version <= test_version <= end_version
        except Exception as e:
            print("Error: could not parse version.")
            print(e)
            return None

    def is_vulnerable(self, data=None, proxies=None):
        readme = False
        try:
            readme = self._readme_file(proxies)
        except Exception as e:
            self._save_log(e, "Error: find version of plugin with readme file failed.", False)
        return readme

    def _readme_file(self, proxies):
        url = self._url+"/wp-content/plugins/wordpress-database-reset/readme.txt"
        response = self._http.request(url=url, method="GET", proxies=proxies)
        if response is None:
            return False
        if "Stable tag:" not in response.text:
            return False
        version = response.text.split("Stable tag:")[1].split("\n")[0]  # get the version of the plugin
        return self.is_vulnerable_version(version)



    def exploit(self, data=None, proxies=None):
        pass

    def _build_version(self, version):
        version = str(version).split(".")
        build_version = 0
        try:
            for index in version:
                build_version = (build_version * 10) + int(index)
            return build_version
        except Exception as e:
            self._save_log(e, "Error: while parsing version number: "+str(version), True)
            raise Exception()


class WPDatabaseReset(WPPluginExploiter):

    def __init__(self, domain):
        super().__init__(domain)
        self._plugin_version_start = 0
        self._plugin_version_end = "3.15"
        self._plugin_version_start_op = " <= "
        self._plugin_version_end_op = " < "
        self._references = ['https://www.wordfence.com/blog/2020/01/easily-exploitable-vulnerabilities-patched-in-wp-database-reset-plugin',
                            'https://blog.qualys.com/webappsec/2020/01/24/wordpress-database-reset-plugin-vulnerability-cve-2020-7047-cve-2020-7048',
                            'https://wpvulndb.com/vulnerabilities/10027']

