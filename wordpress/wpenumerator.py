"""
This Package is responsible to enumerate users on WordPress web site.
The global parameters are available to modify at config.py - under the "enumerator_data".
:global start_enumeration: the specific id to start enumerating from
:global enumeration_chunk: the number of enumerations (e.g 5: start at id 1 enumerating until id 6)
:global rest_api_path: the path for the web rest api
:global rest_api_id_col: the name of the id key at the rest api dict.
:global rest_api_slug_col: the name of the slug key at the rest api dict.
:global rest_api_name_col: the name of the name key at the rest api dict.
:global rest_api_status_col: the name of the status key at the rest api dict.
:global author_path: the path to the author (to catch the name of the author)
:global success_code: this code will approve success request.
:requirements - python3.X, urllib.parse, requests, urllib3, json, asyncio, datetime
"""
try:
    import json

    from config import get_config_for, logs
    from http_handler import HTTPHandler
    from wordpress import WPDetector
except BaseException as e:
    if 'logs' in dir():
        logs.save_log("Import Error: {}".format(e))
    print("Import Error: {}".format(e))

enumerator_data = get_config_for('enumerator_data')
_DEFAULT_START_ENUMERATION = enumerator_data.get('start_enumeration', 1)
_DEFAULT_ENUMERATION_CHUNK = enumerator_data.get('enumeration_chunk', 5)
_REST_API_PATH = enumerator_data.get('rest_api_path', "/wp-json/wp/v2/users/")
_REST_API_ID_COL = enumerator_data.get('rest_api_id_col', 'id')
_REST_API_SLUG_COL = enumerator_data.get('rest_api_slug_col', 'slug')
_REST_API_NAME_COL = enumerator_data.get('rest_api_name_col', 'name')
_REST_API_STATUS_COL = enumerator_data.get('rest_api_status_col', 'data')
_AUTHOR_PATH = enumerator_data.get('author_path', "/?author=")
_SUCCESS_CODE = enumerator_data.get('success_code', 200)


class WPEnumerator:
    """
    This class will enumerate WordPress web sites' users with known and effective methods (if possible)
    :method enumerate: start enumerating for chuck users.
    :method get_usernames: return the usernames from previously enumerating.
    :method get_users_data: return the users data from previously enumerating.
    """

    def __init__(self, domain, additional_data=None, proxies=None):
        """
        :param domain: the URL for the WordPress site.
        :param additional_data: extra data.
        :param proxies: proxies to use in the enumerating process (highly recommended to avoid blocking)
        """
        self._additional_data = additional_data
        self._users = dict()
        self._http_request = HTTPHandler()
        self._url = "{}".format(domain).strip('/').lower()
        self._rest_api_enumeration_is_possible = False
        self._author_enumeration_is_possible = False
        self._enumeration_start = _DEFAULT_START_ENUMERATION
        self._enumeration_finish = self._enumeration_start + _DEFAULT_ENUMERATION_CHUNK
        self._is_wp = False
        self._logs = logs
        self._proxies = proxies
        self._wp_detector = WPDetector(self._url, proxies)
        self.__initial()

    def enumerate(self, min_id=None, max_id=None, proxies=None):
        """
        This method will enumerate chunk of users from the given url in the initial method. (if possible)
        This method is using several well known and effective enumeration methods on a WordPress web site.
        :param min_id: start enumerate id
        :param max_id: finish the enumerating at this id.
        :param proxies: proxies to use in the enumerating process (highly recommended to avoid blocking)
        :return: dict of the successful enumerations
        """
        try:
            if proxies is None:
                proxies = self._proxies
            if self.is_enumeration_possible() is False:
                print("\tEnumeration is not possible for this web site.")
                return None  # if the enumeration is not possible => dont try just return empty dict
            if min_id is None:
                min_id = self._enumeration_start
            if max_id is None:
                max_id = self._enumeration_finish
            if self._rest_api_enumeration_is_possible is True:
                try:
                    print("Trying Enumeration through rest api (chunks)")
                    self._users.update(self.__rest_api_enumeration_all(proxies=proxies))
                except BaseException as e:
                    print("\tEnumeration by rest api failed, please check the logs file.")
                    self._logs.save_log(e, "Error: Function Rest Api Enumeration (by chunks) Failed.")
                try:
                    print("Trying Enumeration through rest api (individuals)")
                    self._users.update(self.__rest_api_enumeration_individual(min_id, max_id, proxies=proxies))
                except BaseException as e:
                    print("\tEnumeration by the rest api failed, please check the logs file.")
                    self._logs.save_log(e, "Error: Function Rest Api Enumeration (Individual) Failed.")
            elif self._author_enumeration_is_possible is True:
                try:
                    print("Trying Enumeration by the Author url")
                    self._users.update(self.__author_enumeration(min_id, max_id, proxies=proxies))
                except BaseException as e:
                    print("\tEnumeration by the Author url is failed, please check the logs file.")
                    self._logs.save_log(e, "Error: Function Author Enumeration is Failed.")
        except BaseException as e:
            print("Something went wrong, please check the logs file.", e)
            self._logs.save_log(e)
        finally:
            return self._users if len(self._users) > 0 else None

    def get_usernames(self):
        """
        This method will return all the usernames from previous enumerations.
        :return: list
        """
        try:
            return list(self._users.values())
        except BaseException as e:
            print("Something went wrong, please check the logs file.", e)
            self._logs.save_log(e, "Error: get_usernames method as crashed.")
            return []

    def get_users_data(self):
        """
        This method wil return all the usernames data from previous enumerations.
        :return: dict
        """
        return self._users

    def __rest_api_enumeration_all(self, proxies=None):
        """
        This private method performs the enumeration through rest api approach (in chunks)
        and not individuals.
        :return: dict
        """
        if proxies is None:
            proxies = self._proxies
        target = "{}{}".format(self._url, _REST_API_PATH)
        users = dict()
        response = self._http_request.request(target, "GET", proxies=proxies)
        if response is None:
            return users
        if response.status_code is not _SUCCESS_CODE:
            return users
        data = json.loads(response.content)
        for user in data:
            if user is _REST_API_STATUS_COL:
                return None  # the data is not good.
            try:
                user = json.loads(json.dumps(user))
                users[user[_REST_API_ID_COL]] = user[_REST_API_SLUG_COL]
            except:
                continue  # user parse failed, continue to the next one.
        return users

    def __rest_api_enumeration_individual(self, min_id, max_id, proxies=None):
        """
        This private method performs the enumeration through rest api approach (individuals)
        and not chunks.
        :param min_id: start enumerate id.
        :param max_id: finish the enumerating at this id.
        :return: dict
        """
        if proxies is None:
            proxies = self._proxies
        url = self._url
        users = dict()
        for i in range(min_id, max_id):
            try:
                target = "{}{}{}".format(url, _REST_API_PATH, i)
                response = self._http_request.request(target, "GET", proxies=proxies)
                if response is None:
                    return users
                if response.status_code is not _SUCCESS_CODE:
                    continue
                user = json.loads(response.content)
                user = json.loads(json.dumps(user))
                if user.get(_REST_API_STATUS_COL, None) is not None:
                    continue
                users[user[_REST_API_ID_COL]] = user[_REST_API_SLUG_COL]
            except:
                continue  # continue to the next one in case of failed.
        self._enumeration_start = max_id
        self._enumeration_finish = max_id + _DEFAULT_ENUMERATION_CHUNK
        return users

    def __author_enumeration(self, min_id, max_id, proxies=None):
        """
        This private method performs the enumeration through author approach (individuals)
        and not chunks.
        :param min_id: start enumerate id.
        :param max_id: finish the enumerating at this id.
        :return: dict
        """
        if proxies is None:
            proxies = self._proxies
        url = self._url
        users = dict()
        for i in range(min_id, max_id):
            try:
                target = "{}{}{}".format(url, _AUTHOR_PATH, i)
                response = self._http_request.request(target, "GET", proxies=proxies)
                if response is None:
                    continue
                response = "{}".format(response.url).strip('/')\
                    .replace("https://", "").replace("http://", "").replace("www.", "")
                target = target.replace("https://", "").replace("http://", "").replace("www.", "")
                if response != target and "/author/" in response:  # we found user
                    if response[-1] is "/":
                        response = response[:-1]
                    user_name = response.replace("-", "").split("/")
                    user_name = user_name[len(user_name) - 1]
                    users[i] = user_name
            except:
                continue  # enumeration for the user id: i => is failed, continue to the next one.
        self._enumeration_start = max_id
        self._enumeration_finish = max_id + _DEFAULT_ENUMERATION_CHUNK
        return users

    def __test_rest_api_enumeration(self, proxies=None):
        """
        This private method is used to check if enumeration is possible through rest api approach.
        The method performs a few tests to determine if it is possible or not.
        :return: none
        """
        if proxies is None:
            proxies = self._proxies
        try:
            target = "{}{}".format(self._url, _REST_API_PATH)
            response = self._http_request.request(target, "GET", proxies=proxies)
            if response is None:
                return
            if response.status_code is not _SUCCESS_CODE:
                return
            data = json.loads(response.content)
            if type(data) is list:
                data = data[0]
            if type(data) is not dict:
                return
            if data.get(_REST_API_STATUS_COL, None) is not None:
                return
            self._rest_api_enumeration_is_possible = True
        except BaseException as e:
            self._logs.save_log(e, "Error: __test_rest_api_enumeration crashed.")
            return

    def __test_author_enumeration(self, proxies=None):
        """
        This private method is used to check if enumeration is possible through author approach.
        The method performs a few tests to determine if it is possible or not.
        :return: none
        """
        if proxies is None:
            proxies = self._proxies
        try:
            target = "{}{}1".format(self._url, _AUTHOR_PATH)
            response = self._http_request.request(target, "GET", proxies=proxies)
            if response is None:
                return
            response_url = "{}".format(response.url).strip('/') \
                .replace("https://", "").replace("http://", "").replace("www.", "")
            target = target.replace("https://", "").replace("http://", "").replace("www.", "")
            if "/author/" in response_url:  # we found user
                self._author_enumeration_is_possible = True
            if response_url == target and response.content == 404:
                self._author_enumeration_is_possible = True
        except BaseException as e:
            self._logs.save_log(e, "Error: __test_author_enumeration crashed.")
            return

    def __initial(self):
        """
        This method performs some initial operations.
        :return: none
        """
        self._url = self._url.strip('/')
        self._is_wp = self.__test_if_wp()
        if self._is_wp is True:
            self.__test_author_enumeration()
            self.__test_rest_api_enumeration()

    def __test_if_wp(self):
        """
        This private method is used to check if the given URL is a WordPress site or not.
        :return: boolean
        """
        try:
            if self._wp_detector.get_version(self._url) is "Unknown":
                return self._wp_detector.detect(self._url)
            return True
        except BaseException as e:
            self._logs.save_log(e, "Error: __test_if_wp crashed.")
            return False

    def is_enumeration_possible(self):
        try:
            return self._rest_api_enumeration_is_possible or self._author_enumeration_is_possible
        except BaseException as e:
            print("Something went wrong, please check the logs file.", e)
            self._logs.save_log(e, "Error: is_enumeration_possible method crushed.")
            return False
