from http_handler.request_handler import HTTPHandler
from wordpress.wpdetector import WPDetector
import json
from wordpress.wplogs import WPLogs

_DEFAULT_START_ENUMERATION = 1
_DEFAULT_ENUMERATION_CHUNK = 5
_REST_API_PATH = "/wp-json/wp/v2/users/"
_REST_API_ID_COL = "id"
_REST_API_SLUG_COL = "slug"
_REST_API_NAME_COL = "name"
_REST_API_STATUS_COL = "data"
_AUTHOR_PATH = "/?author="
_SUCCESS_CODE = 200


class WPEnumerator:

    def __init__(self, domain, additional_data=None, proxies=None):
        self._additional_data = additional_data
        self._users = dict()
        self._http_request = HTTPHandler()
        self._url = str(domain)
        self._rest_api_enumeration_is_possible = False
        self._author_enumeration_is_possible = False
        self._enumeration_start = _DEFAULT_START_ENUMERATION
        self._enumeration_finish = self._enumeration_start + _DEFAULT_ENUMERATION_CHUNK
        self._is_wp = False
        self._logs = WPLogs()
        self._wp_detector = WPDetector(self._url, proxies)
        self.__initial()

    def enumerate(self, min_id=None, max_id=None, proxies=None):
        # if self._is_wp is False or\
        #         (self._author_enumeration_is_possible is False and self._rest_api_enumeration_is_possible is False):
        if self.is_enumeration_possible() is False:
            return None  # if the enumeration is not possible => dont try just return None.
        if min_id is None:
            min_id = self._enumeration_start
        if max_id is None:
            max_id = self._enumeration_finish
        if self._rest_api_enumeration_is_possible is True:
            try:
                self._users.update(self.__rest_api_enumeration_all())
            except Exception as e:
                self.__save_log(e, "Error: Function Rest Api Enumeration Individual is Failed.", True)
            try:
                self._users.update(self.__rest_api_enumeration_individual(min_id, max_id))
            except Exception as e:
                self.__save_log(e, "Error: Function Rest Api Enumeration Individual is Failed.", True)
        elif self._author_enumeration_is_possible is True:
            try:
                self._users.update(self.__author_enumeration(min_id, max_id))
            except Exception as e:
                self.__save_log(e, "Error: Function Author Enumeration is Failed.", True)
        return self._users

    def get_usernames(self):
        return list(self._users.values())

    def get_users_data(self):
        return self._users

    def __rest_api_enumeration_all(self):
        url = self._url
        users = dict()
        target = url + _REST_API_PATH
        try:
            response = self._http_request.request(target, "GET")
            if response is None:
                return users
            if response.status_code is not _SUCCESS_CODE:
                return users
        except Exception as e:
            self.__save_log(e, "Error: request from __rest_api_enumeration_all to "+self._url+" is failed.", True)
            return users
        try:
            data = json.loads(response.content)
            for user in data:
                if user is _REST_API_STATUS_COL:
                    return None  # the data is not good.
                try:
                    user = json.loads(json.dumps(user))
                    users[user[_REST_API_ID_COL]] = user[_REST_API_SLUG_COL]
                except:
                    continue  # user parse if faild, continue to the next one.
        except Exception as e:
            self.__save_log(e, "Error: failed in parse data dict (at __rest_api_enumeration_all)", True)
        return users

    def __rest_api_enumeration_individual(self, min_id, max_id):
        url = self._url
        users = dict()
        for i in range(min_id, max_id):
            try:
                target = url + _REST_API_PATH + str(i)
                response = self._http_request.request(target, "GET")
                if response is None:
                    return users
                if response.status_code is not _SUCCESS_CODE:
                    continue
                user = json.loads(response.content)
                user = json.loads(json.dumps(user))
                if user.get(_REST_API_STATUS_COL, None) is not None:
                    continue
                users[user[_REST_API_ID_COL]] = user[_REST_API_SLUG_COL]
            except:
                continue
        self._enumeration_start = max_id
        self._enumeration_finish = max_id + _DEFAULT_ENUMERATION_CHUNK
        return users

    def __author_enumeration(self, min_id, max_id):
        url = self._url
        users = dict()
        for i in range(min_id, max_id):
            try:
                target = url + _AUTHOR_PATH + str(i)
                response = self._http_request.request(target, "GET")
                if response is None:
                    continue
                response = str(response.url).replace("https", "http").replace("www.", "")
                target = target.replace("https", "http").replace("www.", "")
                if response != target and "/author/" in response:  # we found user
                    if response[-1] is "/":
                        response = response[:-1]
                    user_name = response.replace("-", "").split("/")
                    user_name = user_name[len(user_name) - 1]
                    users[i] = user_name
            except:
                continue  # enumeration for the user id: i => is failed, continue to the next one.
        self._enumeration_start = max_id
        self._enumeration_finish = max_id + _DEFAULT_ENUMERATION_CHUNK
        return users

    def __clean_url(self):
        if self._url[-1:] is "/":
            self._url = self._url[:-1]

    def __test_rest_api_enumeration(self):
        target = self._url + _REST_API_PATH
        try:
            response = self._http_request.request(target, "GET")
            if response is None:
                return
            if response.status_code is not _SUCCESS_CODE:
                return
        except Exception as e:
            self.__save_log(e, "Error: request for "+target+" is failed from function __test_rest_api_enumeration.", True)
            return
        try:
            data = json.loads(response.content)
        except Exception as e:
            self.__save_log(e, "Error: load json data to dict is failed.", True)
            return
        try:
            if data.get(_REST_API_STATUS_COL, None) is not None:
                return
        except:
            self._rest_api_enumeration_is_possible = True

    def __test_author_enumeration(self):
        target = self._url + _AUTHOR_PATH + "1"
        try:
            response = self._http_request.request(target, "GET")
            if response is None:
                return
            response = str(response.url).replace("https", "http").replace("www.", "")
            target = target.replace("https", "http").replace("www.", "")
            if response == target or "/author/" in response:  # we found user
                self._author_enumeration_is_possible = True
        except Exception as e:
            self.__save_log(e,
                            "Error: request for " + target + " is failed from function __test_rest_api_enumeration.")

    def __initial(self):
        self.__clean_url()
        self._is_wp = self.__test_if_wp()
        if self._is_wp is True:
            self.__test_author_enumeration()
            self.__test_rest_api_enumeration()

    def __test_if_wp(self):
        if self._wp_detector.get_version(self._url) is "Unknown":
            return self._wp_detector.detect(self._url)
        return True

    def is_enumeration_possible(self):
        return self._rest_api_enumeration_is_possible or self._author_enumeration_is_possible

    def __save_log(self, e, msg=None, print_msg=False):
        if print_msg is True:
            print(msg)
        self._logs.save_log(e, msg)
